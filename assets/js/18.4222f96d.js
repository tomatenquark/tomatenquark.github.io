(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{389:function(e,t,a){"use strict";a.r(t);var s=a(43),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"preface"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#preface"}},[e._v("#")]),e._v(" Preface")]),e._v(" "),a("p",[e._v("Note: When dealing with array attributes (getting a piece of information from a list of values) it is important to know that most start at zero (0) and count upwards from there. This means that the first value is 0, the second is 1, the third is 2 and so forth. Please keep this in mind, especially when dealing with entity attributes, as zero is always considered to be the first/default value, not 1.")]),e._v(" "),a("h2",{attrs:{id:"summary-of-the-most-common-editing-commands"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#summary-of-the-most-common-editing-commands"}},[e._v("#")]),e._v(" Summary of the most common editing commands")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://tomatenquark.github.io/#/game/EDITREF?id=newmap",target:"_blank",rel:"noopener noreferrer"}},[e._v("newmap N"),a("OutboundLink")],1),a("br"),e._v("\nStarts a new map with scale N (10..16). (tip: very large maps consume more processing)."),a("br"),e._v(" "),a("code",[e._v("/newmap 12")])]),e._v(" "),a("li",[a("a",{attrs:{href:"https://tomatenquark.github.io/#/game/EDITREF?id=skylight",target:"_blank",rel:"noopener noreferrer"}},[e._v("skylight R G B"),a("OutboundLink")],1),a("br"),e._v("\nSets the sky light of the map with colors R G B (0..255)."),a("br"),e._v(" "),a("code",[e._v("/skylight 125 50 50")])]),e._v(" "),a("li",[a("a",{attrs:{href:"https://tomatenquark.github.io/#/game/EDITREF?id=sunlight",target:"_blank",rel:"noopener noreferrer"}},[e._v("sunlight R G B"),a("OutboundLink")],1),a("br"),e._v("\nSets the sun light of the map with colors R G B (0..255). (tip: look somewhere and type /getsundir)."),a("br"),e._v(" "),a("code",[e._v("/sunlight 255 255 120")])]),e._v(" "),a("li",[a("a",{attrs:{href:"https://tomatenquark.github.io/#/game/EDITREF?id=calclight",target:"_blank",rel:"noopener noreferrer"}},[e._v("calclight"),a("OutboundLink")],1),a("br"),e._v('\nRenders the map lights and shadows. (tip: to get a result, the map needs skylight/sunlight defined or some "light" entity available).'),a("br"),e._v(" "),a("code",[e._v("/calclight")])]),e._v(" "),a("li",[a("a",{attrs:{href:"https://tomatenquark.github.io/#/game/EDITREF?id=savemap",target:"_blank",rel:"noopener noreferrer"}},[e._v("savemap S"),a("OutboundLink")],1),a("br"),e._v('\nSaves the current map with the name S in the "packages/base" folder. (tip: to see all your saved maps, type /mymaps).'),a("br"),e._v(" "),a("code",[e._v("/savemap mymap")])]),e._v(" "),a("li",[a("a",{attrs:{href:"https://tomatenquark.github.io/#/game/EDITREF?id=newent",target:"_blank",rel:"noopener noreferrer"}},[e._v("newent"),a("OutboundLink")],1),a("br"),e._v("\nCreates a new entity."),a("br"),e._v(" "),a("code",[e._v("/newent light 200 200 200")])]),e._v(" "),a("li",[a("a",{attrs:{href:"https://tomatenquark.github.io/#/game/EDITREF?id=allfaces",target:"_blank",rel:"noopener noreferrer"}},[e._v("allfaces B"),a("OutboundLink")],1),a("br"),e._v("\nIf enabled, add the texture to all faces of the selected cube."),a("br"),e._v(" "),a("code",[e._v("/allfaces 1")])]),e._v(" "),a("li",[a("a",{attrs:{href:"https://tomatenquark.github.io/#/game/EDITREF?id=gridpower",target:"_blank",rel:"noopener noreferrer"}},[e._v("gridpower N"),a("OutboundLink")],1),a("br"),e._v("\nDefines the size of the editing grid as N (0..12). (tip: very small grids will allow more detailed editing, however it can compromise the framerate of your map)."),a("br"),e._v(" "),a("code",[e._v("/gridpower 5")]),e._v(" "),a("hr")])]),e._v(" "),a("h2",{attrs:{id:"editing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#editing"}},[e._v("#")]),e._v(" Editing")]),e._v(" "),a("h3",{attrs:{id:"edittoggle"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#edittoggle"}},[e._v("#")]),e._v(" edittoggle")]),e._v(" "),a("p",[a("code",[e._v("edittoggle")])]),e._v(" "),a("p",[e._v('Switches between map edit mode and normal (default key: e). In map edit mode you can select bits of the map by clicking or dragging your crosshair on the cubes (using the "attack" command, normally MOUSE1), then use the commands below to modify the selection. While in edit mode, physics & collision don\'t apply (noclip), and key repeat is ON.')]),e._v(" "),a("h3",{attrs:{id:"dragging"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dragging"}},[e._v("#")]),e._v(" dragging")]),e._v(" "),a("p",[a("code",[e._v("dragging B")])]),e._v(" "),a("p",[e._v("Select cubes when set to 1. stop selection when set to 0")]),e._v(" "),a("h3",{attrs:{id:"editdrag"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#editdrag"}},[e._v("#")]),e._v(" editdrag")]),e._v(" "),a("p",[a("code",[e._v("editdrag")])]),e._v(" "),a("p",[e._v("Select cubes and entities. (default: left mouse button)")]),e._v(" "),a("h3",{attrs:{id:"selcorners"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#selcorners"}},[e._v("#")]),e._v(" selcorners")]),e._v(" "),a("p",[a("code",[e._v("selcorners")])]),e._v(" "),a("p",[e._v("Select the corners of cubes. (default: middle mouse button)")]),e._v(" "),a("h3",{attrs:{id:"moving"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#moving"}},[e._v("#")]),e._v(" moving")]),e._v(" "),a("p",[a("code",[e._v("moving B")])]),e._v(" "),a("p",[e._v("set to 1 to turn on. when on, it will move the selection (cubes not included) to another position. the plane on which it will move on is dependent on which side of the selection your cursor was on when turned on. set to 0 to turn off moving. if cursor is not on selection when turned on, moving will automatically be turned off.")]),e._v(" "),a("h3",{attrs:{id:"editmovedrag"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#editmovedrag"}},[e._v("#")]),e._v(" editmovedrag")]),e._v(" "),a("p",[a("code",[e._v("editmovedrag")])]),e._v(" "),a("p",[e._v("if cursor is in current cube selection, holding will move selection. otherwise will create new selection.")]),e._v(" "),a("h3",{attrs:{id:"cancelsel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cancelsel"}},[e._v("#")]),e._v(" cancelsel")]),e._v(" "),a("p",[a("code",[e._v("cancelsel")])]),e._v(" "),a("p",[e._v("Cancels out any explicit selection you currently have (default: space).")]),e._v(" "),a("h3",{attrs:{id:"editface"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#editface"}},[e._v("#")]),e._v(" editface")]),e._v(" "),a("p",[a("code",[e._v("editface D N")])]),e._v(" "),a("p",[e._v("This is the main editing command. D is the direction of the action, -1 for towards you, 1 for away from you (default: scroll wheel). N=0 to push all corners in the white box (hold F). N=1 create or destroy cubes (default). N=2 push or pull a corner you are pointing at (hold Q).")]),e._v(" "),a("h3",{attrs:{id:"gridpower"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gridpower"}},[e._v("#")]),e._v(" gridpower")]),e._v(" "),a("p",[a("code",[e._v("gridpower N")])]),e._v(" "),a("p",[e._v("Changes the size of the grid. (default: g + scrollwheel)")]),e._v(" "),a("h3",{attrs:{id:"edittex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#edittex"}},[e._v("#")]),e._v(" edittex")]),e._v(" "),a("p",[a("code",[e._v("edittex D")])]),e._v(" "),a("p",[e._v("Changes the texture on current selection by browsing through a list of textures directly shown on the cubes. D is the direction you want to cycle the textures in (1 = forwards, -1 = backwards) (default: y + scrollwheel). The way this works is slightly strange at first, but allows for very fast texture assignment. All textures are in a list. and each time a texture is used, it is moved to the top of the list. So after a bit of editing, all your most frequently used textures will come first, and the most recently used texture is set immediately when you press the forward key for the type. These lists are saved with the map.")]),e._v(" "),a("h3",{attrs:{id:"gettex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gettex"}},[e._v("#")]),e._v(" gettex")]),e._v(" "),a("p",[a("code",[e._v("gettex")])]),e._v(" "),a("p",[e._v("moves the texture on the current selection to the top of the texture list. Useful for quickly texturing things using already textured geometry.")]),e._v(" "),a("h3",{attrs:{id:"selextend"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#selextend"}},[e._v("#")]),e._v(" selextend")]),e._v(" "),a("p",[a("code",[e._v("selextend")])]),e._v(" "),a("p",[e._v("Extend current selection to include the cursor.")]),e._v(" "),a("h3",{attrs:{id:"passthrough"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#passthrough"}},[e._v("#")]),e._v(" passthrough")]),e._v(" "),a("p",[a("code",[e._v("passthrough")])]),e._v(" "),a("p",[e._v("normally cubes of equal size to the grid are given priority when selecting. passthrough removes this priority while held down so that the cube the cursor is directly on is selected. Holding down passthrough will also give priority to cube over entities. (default: alt)")]),e._v(" "),a("h3",{attrs:{id:"reorient"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reorient"}},[e._v("#")]),e._v(" reorient")]),e._v(" "),a("p",[a("code",[e._v("reorient")])]),e._v(" "),a("p",[e._v("Change the side the white box is on to be the same as where you are currently pointing. (default: shift)")]),e._v(" "),a("h3",{attrs:{id:"flip"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flip"}},[e._v("#")]),e._v(" flip")]),e._v(" "),a("p",[a("code",[e._v("flip")])]),e._v(" "),a("p",[e._v("Flip (mirror) the selected cubes front to back relative to the side of the white box. (default: x)")]),e._v(" "),a("h3",{attrs:{id:"rotate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rotate"}},[e._v("#")]),e._v(" rotate")]),e._v(" "),a("p",[a("code",[e._v("rotate D")])]),e._v(" "),a("p",[e._v("Rotates the selection 90 degrees around the side of the white box. Automatically squares the selection if it isn't already. (default: r + scroll wheel)")]),e._v(" "),a("h3",{attrs:{id:"undo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#undo"}},[e._v("#")]),e._v(" undo")]),e._v(" "),a("p",[a("code",[e._v("undo")])]),e._v(" "),a("p",[e._v("Multi-level undo of any of the changes caused by the above operations (default: z [or u]).")]),e._v(" "),a("h3",{attrs:{id:"redo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redo"}},[e._v("#")]),e._v(" redo")]),e._v(" "),a("p",[a("code",[e._v("redo")])]),e._v(" "),a("p",[e._v("Multi-level redo of any of the changes caused by the above undo (default: i).")]),e._v(" "),a("h3",{attrs:{id:"copy-paste"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copy-paste"}},[e._v("#")]),e._v(" copy/paste")]),e._v(" "),a("p",[a("code",[e._v("copy")]),e._v(" "),a("code",[e._v("paste")])]),e._v(" "),a("p",[e._v("Copy copies the current selection into a buffer. Upon pressing 'paste', a selection box will be created to identify the location of the pasted cubes. Releasing the 'paste' button will actually paste the cubes. So combined with the 'moving' command you can easily place and clone sets of cubes. If the current gridsize is changed from the copy, the pasted copy will be stretched by the same factor.")]),e._v(" "),a("h3",{attrs:{id:"editcopy-editpaste"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#editcopy-editpaste"}},[e._v("#")]),e._v(" editcopy/editpaste")]),e._v(" "),a("p",[a("code",[e._v("editcopy")]),e._v(" "),a("code",[e._v("editpaste")])]),e._v(" "),a("p",[e._v("Will copy cubes as normal copy, but also features entity copies. There are three different methods of use:")]),e._v(" "),a("ul",[a("li",[e._v("If no entity is explicitly selected, editcopy will copy the selected cube, just like normal the normal 'copy' command.")]),e._v(" "),a("li",[e._v("If one or more entities are selected, editcopy will copy the last entity selected. Editpaste will create a new entity using copy as the template if no entities are selected, otherwise it will overwrite all selected entities with the copied ent.")]),e._v(" "),a("li",[e._v("If there are both entity and cube selections, editcopy will copy the entire selection. In other words, when editpaste is used it will paste the cube selection along with all of the entities that were selected.")])]),e._v(" "),a("h3",{attrs:{id:"replace"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#replace"}},[e._v("#")]),e._v(" replace")]),e._v(" "),a("p",[a("code",[e._v("replace")])]),e._v(" "),a("p",[e._v("Repeats the last texture edit across the whole map. Only those faces with textures matching the one that was last edited will be replaced.")]),e._v(" "),a("h3",{attrs:{id:"replacesel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#replacesel"}},[e._v("#")]),e._v(" replacesel")]),e._v(" "),a("p",[a("code",[e._v("replacesel")])]),e._v(" "),a("p",[e._v("Repeats the last texture edit only within the currently selected region. Only those faces with textures matching the one that was last edited will be replaced.")]),e._v(" "),a("h3",{attrs:{id:"editmat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#editmat"}},[e._v("#")]),e._v(" editmat")]),e._v(" "),a("p",[a("code",[e._v("editmat MAT [FILTER]")])]),e._v(" "),a("p",[e._v('Changes the type of material left behind when a cube is deleted to MAT. If FILTER is specified, then only cubes with that material named by FILTER are changed to MAT. MAT may also be "", indicating that only those parts of the material mask matching FILTER will be cleared, as opposed to setting MAT to "air", which would clear the entire material mask. FILTER may alternatively be one of "empty", "notempty", "solid", and "notsolid" which will then only affect cubes containing such geometry.')]),e._v(" "),a("p",[e._v("Currently the following types of materials are supported:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("air")]),e._v(": the default material, has no effect. Overwrites other volume materials.")]),e._v(" "),a("li",[a("strong",[e._v("water")]),e._v(": acts as you would expect. Renders the top as a reflection/refraction and the sides as a waterfall if it isn't contained. Should be placed with a floor at the bottom to contain it. Shows blue volume in edit mode. Overwrites other volume materials.")]),e._v(" "),a("li",[a("strong",[e._v("glass")]),e._v(": a clip-like material with a blended/reflective surface. Glass also stops bullets. Will reflect the closest envmap entity, or if none is in range, the skybox. Shows cyan volume in edit mode. Overwrites other volume materials.")]),e._v(" "),a("li",[a("strong",[e._v("lava")]),e._v(": renders the top as a glowing lava flow and the sides as lavafalls if it isn't contained. It kills any players who enter it. Shows orange volume in edit mode. Overwrite other volume materials.")]),e._v(" "),a("li",[a("strong",[e._v("clip")]),e._v(': an invisible wall that blocks players movement but not bullets. Is ideally used to keep players "in bounds" in a map. Can be used sparingly to smooth out the flow around decoration. Shows red volume in edit mode. Overwrites other clip materials.')]),e._v(" "),a("li",[a("strong",[e._v("noclip")]),e._v(": cubes are always treated as empty in physics. Shows green volume in edit mode. Overwrites other clip materials.")]),e._v(" "),a("li",[a("strong",[e._v("gameclip")]),e._v(": a game mode specific clip material. Currently it can block monsters in SP modes, it can stop flags from being picked up in areas in CTF/protect modes, and it can stop capturing of bases in areas in capture modes. Overwrites other clip materials.")]),e._v(" "),a("li",[a("strong",[e._v("death")]),e._v(": causes the player to suicide if he is inside the material. Shows black volume in edit mode.")]),e._v(" "),a("li",[a("strong",[e._v("alpha")]),e._v(': all faces of cubes with this material are rendered transparently. Use the "valpha" and "texalpha" commands to control the transparency of front and back faces. Shows pink volume in edit mode.')])]),e._v(" "),a("h3",{attrs:{id:"recalc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#recalc"}},[e._v("#")]),e._v(" recalc")]),e._v(" "),a("p",[a("code",[e._v("recalc")])]),e._v(" "),a("p",[e._v('Recalculates scene geometry. This also will regenerate any envmaps to reflect the changed geometry, and fix any geometry with "bumpenv*" shaders to use the closest available envmaps. This command is also implicitly used by calclight.')]),e._v(" "),a("h3",{attrs:{id:"havesel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#havesel"}},[e._v("#")]),e._v(" havesel")]),e._v(" "),a("p",[a("code",[e._v("havesel")])]),e._v(" "),a("p",[e._v("Returns the number of explicitly selected cubes for scripting purposes. Returns 0 if the cubes are only implicitly selected.")]),e._v(" "),a("h3",{attrs:{id:"getselpos"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getselpos"}},[e._v("#")]),e._v(" getselpos")]),e._v(" "),a("p",[a("code",[e._v("getselpos")])]),e._v(" "),a("p",[e._v("Returns the position of the currently selected area.")]),e._v(" "),a("h3",{attrs:{id:"setselpos"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setselpos"}},[e._v("#")]),e._v(" setselpos")]),e._v(" "),a("p",[a("code",[e._v("setselpos x y z")])]),e._v(" "),a("p",[e._v("Sets the position of the selection.")]),e._v(" "),a("h3",{attrs:{id:"movesel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#movesel"}},[e._v("#")]),e._v(" movesel")]),e._v(" "),a("p",[a("code",[e._v("movesel dir dim")])]),e._v(" "),a("p",[e._v("Moves the selection towards a direction.")]),e._v(" "),a("h3",{attrs:{id:"gotosel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gotosel"}},[e._v("#")]),e._v(" gotosel")]),e._v(" "),a("p",[a("code",[e._v("gotosel")])]),e._v(" "),a("p",[e._v("Goes to the position of the currently selected cube or entity.")]),e._v(" "),a("h3",{attrs:{id:"savebrush"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#savebrush"}},[e._v("#")]),e._v(" savebrush")]),e._v(" "),a("p",[a("code",[e._v("savebrush S")])]),e._v(" "),a("p",[e._v("Saves the current selection as an octa-brush named S.")]),e._v(" "),a("h3",{attrs:{id:"pastebrush"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pastebrush"}},[e._v("#")]),e._v(" pastebrush")]),e._v(" "),a("p",[a("code",[e._v("pastebrush S")])]),e._v(" "),a("p",[e._v("Pastes the octa-brush named S.")]),e._v(" "),a("h2",{attrs:{id:"heightfield"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#heightfield"}},[e._v("#")]),e._v(" Heightfield")]),e._v(" "),a("p",[e._v("Heightfields are another way of editing the same geometry. Editing this way is a bit different from normal editing, but just as easy. First, instead of selecting cubes, you select a brush (B+wheel) and textures (middle mouse button while in heightmap mode to toggle). Once this is done, you can apply the brush to all cubes that match the textures you've selected. Making hills and valleys can be quite fast when using this feature. By default all textures are automatically selected.")]),e._v(" "),a("h3",{attrs:{id:"hmapedit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hmapedit"}},[e._v("#")]),e._v(" hmapedit")]),e._v(" "),a("p",[a("code",[e._v("hmapedit B")])]),e._v(" "),a("p",[e._v("Set to 1 to turn on heightmap mode (default: hold LCTRL or use H to toggle on and off). In heightmap mode the cursor will turn bright green when hilighting heightmap cubes and the editface command will now use brushes to edit heightmap cubes. In order to avoid accidental edits only heightmap cubes are editable in this mode. If a cubic selection is present, then only cubes within the column of the selection will be modifiable.")]),e._v(" "),a("h3",{attrs:{id:"hmapselect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hmapselect"}},[e._v("#")]),e._v(" hmapselect")]),e._v(" "),a("p",[a("code",[e._v("hmapselect")])]),e._v(" "),a("p",[e._v("Selects the texture and orientation of the hilighted cube (default: mouse buttons while in heightmap mode, or H key). If hmapselall is set to 1, then all textures are automatically selected, and this command will simply select the orientation. All cubes, of equal or larger size, that match the selection will be considered part of the heightmap.")]),e._v(" "),a("h3",{attrs:{id:"hmapcancel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hmapcancel"}},[e._v("#")]),e._v(" hmapcancel")]),e._v(" "),a("p",[a("code",[e._v("hmapcancel")])]),e._v(" "),a("p",[e._v("Return the heightmap texture selection to default (ie: select all textures).")]),e._v(" "),a("h3",{attrs:{id:"selectbrush"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#selectbrush"}},[e._v("#")]),e._v(" selectbrush")]),e._v(" "),a("p",[a("code",[e._v("selectbrush N")])]),e._v(" "),a("p",[e._v("Switches between the various height map brushes (default: hold B + wheel).")]),e._v(" "),a("h3",{attrs:{id:"clearbrush"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clearbrush"}},[e._v("#")]),e._v(" clearbrush")]),e._v(" "),a("p",[a("code",[e._v("clearbrush")])]),e._v(" "),a("p",[e._v("This resets the current brush that is used during heightmap mode editing.")]),e._v(" "),a("h3",{attrs:{id:"brushvert"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#brushvert"}},[e._v("#")]),e._v(" brushvert")]),e._v(" "),a("p",[a("code",[e._v("brushvert x y depth")])]),e._v(" "),a("p",[e._v("A brush is a 2D map that describes the depth that the editface commands should push into the cubes at various points. The first two parameters of brushvert are the X and Y coordinates, respectively, of a vert on this 2D map. The last parameter is used to set the depth. NOTE: if all of the brush verts are 0, then a smoothing filter will be applied instead of the brush. This filter will affect the same square sized region as the brush.")]),e._v(" "),a("h3",{attrs:{id:"brushx-brushy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#brushx-brushy"}},[e._v("#")]),e._v(" brushx/brushy")]),e._v(" "),a("p",[a("code",[e._v("brushx N")]),e._v(" "),a("code",[e._v("brushy N")])]),e._v(" "),a("p",[e._v("Along with the 2D map, all brushes also have a handle. This handle is a reference point on the 2D map which defines where the brush is relative to the editing cursor. These two variables define the brush handle's coordinates.")]),e._v(" "),a("h2",{attrs:{id:"entity"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entity"}},[e._v("#")]),e._v(" Entity")]),e._v(" "),a("h3",{attrs:{id:"newent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#newent"}},[e._v("#")]),e._v(" newent")]),e._v(" "),a("p",[a("code",[e._v("newent type value1 value2 value3 value4")])]),e._v(" "),a("p",[e._v('Adds a new entity where (x,y,z) is determined by the current dropent configuration (camera pos, selection pos...). Type is a string giving the type of entity, such as "light", and may optionally take values (depending on the entity). The types are defines below in the Entity Types section.')]),e._v(" "),a("h3",{attrs:{id:"delent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#delent"}},[e._v("#")]),e._v(" delent")]),e._v(" "),a("p",[a("code",[e._v("delent")])]),e._v(" "),a("p",[e._v("deletes the selected entities")]),e._v(" "),a("h3",{attrs:{id:"entflip"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entflip"}},[e._v("#")]),e._v(" entflip")]),e._v(" "),a("p",[a("code",[e._v("entflip")])]),e._v(" "),a("p",[e._v("Flip the selected entities. cube selection serves as both reference point and orientation to flip around.")]),e._v(" "),a("h3",{attrs:{id:"entpush"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entpush"}},[e._v("#")]),e._v(" entpush")]),e._v(" "),a("p",[a("code",[e._v("entpush D")])]),e._v(" "),a("p",[e._v("Push the selected entities. cube selection serves as orientation to push towards.")]),e._v(" "),a("h3",{attrs:{id:"entrotate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entrotate"}},[e._v("#")]),e._v(" entrotate")]),e._v(" "),a("p",[a("code",[e._v("entrotate D")])]),e._v(" "),a("p",[e._v("Rotate the selected entities in relation to the cube selection.")]),e._v(" "),a("h3",{attrs:{id:"entmoving"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entmoving"}},[e._v("#")]),e._v(" entmoving")]),e._v(" "),a("p",[a("code",[e._v("entmoving N")])]),e._v(" "),a("p",[e._v("Set to 1 to turn on. if an entity is under the cursor when turned on, the entity will get toggled selected/unselected (set to 2 to add to selection instead of toggle). if selected, one can move the entity around using the cursor. if multiple entities are selected, they will also move. the plane on which the entity will be moved is dependent on the orientation of the cube surrounding the entity. set to 0 to turn off moving. if no entity is under the cursor when turned on, it will automatically turn off.")]),e._v(" "),a("h3",{attrs:{id:"entdrop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entdrop"}},[e._v("#")]),e._v(" entdrop")]),e._v(" "),a("p",[a("code",[e._v("entdrop N")])]),e._v(" "),a("p",[e._v('Variable controlling where entities created with "newent" will be placed. N=0 place entities at your current eye position. N=1 drop entities to the floor beneath you. Lights, however, will be placed at your current eye position as for N=0. N=2 place entities at the center of the currently selected cube face. If a corner is selected, the entity will be placed at the corner vertex. N=3 behaves as with N=2, except all entities, including lights, will then bedropped from that position to whatever floor lies beneath. This mode is useful for placing objects on selected floors. Lights are also dropped to the floor, unlike for N=1.')]),e._v(" "),a("h3",{attrs:{id:"dropent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dropent"}},[e._v("#")]),e._v(" dropent")]),e._v(" "),a("p",[a("code",[e._v("dropent")])]),e._v(" "),a("p",[e._v("Positions the selected entity according to the entdrop variable.")]),e._v(" "),a("h3",{attrs:{id:"trigger"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#trigger"}},[e._v("#")]),e._v(" trigger")]),e._v(" "),a("p",[a("code",[e._v("trigger T N")])]),e._v(" "),a("p",[e._v("Sets the state of all locked triggers with tag T to N.")]),e._v(" "),a("h3",{attrs:{id:"platform"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#platform"}},[e._v("#")]),e._v(" platform")]),e._v(" "),a("p",[a("code",[e._v("platform T N")])]),e._v(" "),a("p",[e._v("If N = 0, stops all platforms or elevators with tag T. If N = 1, causes all platforms or elevators with tag T to move forwards or up, respectively. If N = -1, causes all platforms or elevators with tag T to move backwards or down, respectively.")]),e._v(" "),a("h3",{attrs:{id:"entselect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entselect"}},[e._v("#")]),e._v(" entselect")]),e._v(" "),a("p",[a("code",[e._v("entselect X")])]),e._v(" "),a("p",[e._v("Takes a boolean expression as argument. Selects all entities that evaluate to true for the given expression. examples:")]),e._v(" "),a("ul",[a("li",[e._v("entselect insel // select all entities in blue selection box")]),e._v(" "),a("li",[e._v('entselect [ strcmp (et) "shells" ] // select all shells in map')])]),e._v(" "),a("h3",{attrs:{id:"entloop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entloop"}},[e._v("#")]),e._v(" entloop")]),e._v(" "),a("p",[a("code",[e._v("entloop X")])]),e._v(" "),a("p",[e._v("Loops through and executes the given expression for all selected entities. Note that most of the entity commands are already vector based and will automatically do this. Therefore they don't need to be explicitly executed within an entloop. Entloop is to be used when more precise custom instructions need to be executed on a selection.")]),e._v(" "),a("p",[e._v("Another property of entloop is that entity commands within it, that are normally executed on the entire selection, will only be done on the current entity iterator. In other words, the two following examples are equivalent:")]),e._v(" "),a("p",[e._v("The entset in the second statement will NOT be applied n squared times. Entloops can be nested.")]),e._v(" "),a("h3",{attrs:{id:"entcancel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entcancel"}},[e._v("#")]),e._v(" entcancel")]),e._v(" "),a("p",[a("code",[e._v("entcancel")])]),e._v(" "),a("p",[e._v("Deselect all entities.")]),e._v(" "),a("h3",{attrs:{id:"enthavesel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#enthavesel"}},[e._v("#")]),e._v(" enthavesel")]),e._v(" "),a("p",[a("code",[e._v("enthavese")])]),e._v(" "),a("p",[e._v("Returns the number of entities in the current selection.")]),e._v(" "),a("h3",{attrs:{id:"entget"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entget"}},[e._v("#")]),e._v(" entget")]),e._v(" "),a("p",[a("code",[e._v("entget")])]),e._v(" "),a("p",[e._v('Returns a string in the form of "type value1 value2 value3 value4". This string is the definition of the current selected entity. For example, the following statement will display the values of all the entities within the current selection:')]),e._v(" "),a("p",[e._v("Outside of an entloop, the last entity selected will be returned. Normally, if an entity is highlighted by the cursor, it will only be considered as in the selection if an explicit one does not exisit (like cubic selections). However, entget is special in that it considers the highlighted entity as being the last entity in the selection. Entget is used to generate the default entdisplay at the bottom of the screen.")]),e._v(" "),a("h3",{attrs:{id:"insel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#insel"}},[e._v("#")]),e._v(" insel")]),e._v(" "),a("p",[a("code",[e._v("insel")])]),e._v(" "),a("p",[e._v("Returns true if the selected entity is inside the cube selection")]),e._v(" "),a("h3",{attrs:{id:"et"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#et"}},[e._v("#")]),e._v(" et")]),e._v(" "),a("p",[a("code",[e._v("et")])]),e._v(" "),a("p",[e._v("Cuts out the 'type' field from entget.")]),e._v(" "),a("h3",{attrs:{id:"ea"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ea"}},[e._v("#")]),e._v(" ea")]),e._v(" "),a("p",[a("code",[e._v("ea N")])]),e._v(" "),a("p",[e._v("Cuts out the given 'value' field from entget. Attributes are numbered 0 to 3.")]),e._v(" "),a("h3",{attrs:{id:"entset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entset"}},[e._v("#")]),e._v(" entset")]),e._v(" "),a("p",[a("code",[e._v("entset type value1 value2 value3 value4")])]),e._v(" "),a("p",[e._v("Change the type and attributes of the selected entity. To quickly bring up the entset command in the console press '.' (default: period). It will come pre-filled with the values of the current entity selection (from entget).")]),e._v(" "),a("h3",{attrs:{id:"entproperty"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entproperty"}},[e._v("#")]),e._v(" entproperty")]),e._v(" "),a("p",[a("code",[e._v("entproperty P A")])]),e._v(" "),a("p",[e._v('Changes property P (0..3) of the selected entities by amount A. For example "entproperty 0 2" when executed near a lightsource would increase its radius by 2.')]),e._v(" "),a("h3",{attrs:{id:"entfind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entfind"}},[e._v("#")]),e._v(" entfind")]),e._v(" "),a("p",[a("code",[e._v("entfind type value1 value2 value3 value4")])]),e._v(" "),a("p",[e._v("Select all entities matching given values. "),a("code",[e._v("*")]),e._v(" and blanks are wildcard. All ents that match the pattern will be ADDED to the selection.")]),e._v(" "),a("h3",{attrs:{id:"clearents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clearents"}},[e._v("#")]),e._v(" clearents")]),e._v(" "),a("p",[a("code",[e._v("clearents type")])]),e._v(" "),a("p",[e._v("Deletes all entities of said type.")]),e._v(" "),a("h3",{attrs:{id:"replaceents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#replaceents"}},[e._v("#")]),e._v(" replaceents")]),e._v(" "),a("p",[a("code",[e._v("replaceents type value1 value2 value3 value4")])]),e._v(" "),a("p",[e._v("Replaces the given values for the selected entity and all entities that are equal to the selected entity. To quickly bring up the replaceents command in the console press ',' (default: comma). It will come pre-filled with the values of the current entity selection.")]),e._v(" "),a("h3",{attrs:{id:"entautoview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entautoview"}},[e._v("#")]),e._v(" entautoview")]),e._v(" "),a("p",[a("code",[e._v("entautoview N")])]),e._v(" "),a("p",[e._v("Centers view on selected entity. Increment through selection by N. ex: N = 1 => next, N = -1 => previous. entautoviewdist N, sets the distance from entity.")]),e._v(" "),a("h2",{attrs:{id:"settings"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#settings"}},[e._v("#")]),e._v(" Settings")]),e._v(" "),a("h3",{attrs:{id:"undomegs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#undomegs"}},[e._v("#")]),e._v(" undomegs")]),e._v(" "),a("p",[a("code",[e._v("undomegs N")])]),e._v(" "),a("p",[e._v("Sets the number of megabytes used for the undo buffer (default 5, max 100). Undo's work for any size areas, so the amount of undo steps per megabyte is more for small areas than for big ones.")]),e._v(" "),a("h3",{attrs:{id:"showsky"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#showsky"}},[e._v("#")]),e._v(" showsky")]),e._v(" "),a("p",[a("code",[e._v("showsky B")])]),e._v(" "),a("p",[e._v("This variable controls whether explicit sky polygons are outlined (in purple) in edit mode. Default = 1.")]),e._v(" "),a("h3",{attrs:{id:"outline"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#outline"}},[e._v("#")]),e._v(" outline")]),e._v(" "),a("p",[a("code",[e._v("outline 0/1")])]),e._v(" "),a("p",[e._v("This variable controls whether geometry boundaries (outlines) are shown. Default = 0.")]),e._v(" "),a("h3",{attrs:{id:"wireframe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#wireframe"}},[e._v("#")]),e._v(" wireframe")]),e._v(" "),a("p",[a("code",[e._v("wireframe 0/1")])]),e._v(" "),a("p",[e._v("Turns off/on wireframe drawing of the map.")]),e._v(" "),a("h3",{attrs:{id:"allfaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#allfaces"}},[e._v("#")]),e._v(" allfaces")]),e._v(" "),a("p",[a("code",[e._v("allfaces 0/1")])]),e._v(" "),a("p",[e._v("When on, causes the texturing commands to apply the new texture to all sides of the selected cubes rather than just the selected face.")]),e._v(" "),a("h3",{attrs:{id:"showmat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#showmat"}},[e._v("#")]),e._v(" showmat")]),e._v(" "),a("p",[a("code",[e._v("showmat 0/1")])]),e._v(" "),a("p",[e._v("This variables whether volumes are shown for invisible material surfaces in edit mode. Material volumes may also be selected while this is enabled. Default = 1.")]),e._v(" "),a("h3",{attrs:{id:"optmats"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#optmats"}},[e._v("#")]),e._v(" optmats")]),e._v(" "),a("p",[a("code",[e._v("optmats 0/1")])]),e._v(" "),a("p",[e._v("This variables controls whether material rendering should be optimized by grouping materials into the largest possible surfaces. This will always make rendering faster, so the only reason to disable it is for testing. Default = 1.")]),e._v(" "),a("h3",{attrs:{id:"entselradius"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entselradius"}},[e._v("#")]),e._v(" entselradius")]),e._v(" "),a("p",[a("code",[e._v("entselradius N")])]),e._v(" "),a("p",[e._v("Sets the 'handle' size of entities when trying to select them. Larger sizes means it should be easier to select entities.")]),e._v(" "),a("h3",{attrs:{id:"entselsnap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entselsnap"}},[e._v("#")]),e._v(" entselsnap")]),e._v(" "),a("p",[a("code",[e._v("entselsnap 0/1")])]),e._v(" "),a("p",[e._v("Turns on snap-to-grid while draggin entities. (default: 6)")]),e._v(" "),a("h3",{attrs:{id:"entitysurf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entitysurf"}},[e._v("#")]),e._v(" entitysurf")]),e._v(" "),a("p",[a("code",[e._v("entitysurf 0/1")])]),e._v(" "),a("p",[e._v("When on, you will move with the entity as you push it with the scroll wheel. Of course, in order to push an entity, you must be holding it.")]),e._v(" "),a("h3",{attrs:{id:"selectionsurf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#selectionsurf"}},[e._v("#")]),e._v(" selectionsurf")]),e._v(" "),a("p",[a("code",[e._v("selectionsurf 0/1")])]),e._v(" "),a("p",[e._v("When on, you will move with the selection box as you push it with the scroll wheel. Of course, in order to push a selection box, you must be holding it.")]),e._v(" "),a("h2",{attrs:{id:"map-and-config"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map-and-config"}},[e._v("#")]),e._v(" Map and Config")]),e._v(" "),a("h3",{attrs:{id:"map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[e._v("#")]),e._v(" map")]),e._v(" "),a("p",[a("code",[e._v("map name")])]),e._v(" "),a("p",[e._v('Loads up map "name" in the gamemode set previously by "mode". A map given as "blah" refers to "packages/base/blah.ogz", "mypackage/blah" refers to "packages/mypackage/blah.ogz". The menu has a set of maps that can be loaded. See also map in the gameplay docs.')]),e._v(" "),a("p",[e._v('At every map load, "data/default_map_settings.cfg" is loaded which sets up all texture definitions etc. Everything defined in there can be overridden per package or per map by creating a "package.cfg" or "mapname.cfg" which contains whatever you want to do differently from the default. It can also set up triggers scripts per map etc.')]),e._v(" "),a("p",[e._v('When the map finishes it will load the next map when one is defined, otherwise reloads the current map. You can define what map follows a particular map by making an alias like (in the map script): alias nextmap_blah1 blah2 (loads "blah2" after "blah1").')]),e._v(" "),a("h3",{attrs:{id:"sendmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sendmap"}},[e._v("#")]),e._v(" sendmap")]),e._v(" "),a("p",[a("code",[e._v("sendmap")])]),e._v(" "),a("p",[e._v("Saves the current map (without lightmaps) and sends it to the server so other clients may download it. Only works in coopedit game mode.")]),e._v(" "),a("h3",{attrs:{id:"getmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getmap"}},[e._v("#")]),e._v(" getmap")]),e._v(" "),a("p",[a("code",[e._v("getmap")])]),e._v(" "),a("p",[e._v("Gets a map from the server if one is available. Automatically loads the map when done. Only works in coopedit game mode.")]),e._v(" "),a("h3",{attrs:{id:"savemap-savecurrentmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#savemap-savecurrentmap"}},[e._v("#")]),e._v(" savemap/savecurrentmap")]),e._v(" "),a("p",[a("code",[e._v('savemap "name"')]),e._v(" "),a("code",[e._v("savecurrentmap")])]),e._v(" "),a("p",[e._v('Saves the current map (/showcustommaps), using the same naming scheme as "map". Makes a versioned backup to "mapname_N.BAK" if a map by that name already exists, so you can never lose a map. With "savemap", if you leave out the "name" argument, it is saved under the current map name. With "savecurrentmap", the map is saved with the name determined by the current game. Where you store a map depends on the complexity of what you are creating: if its a single map (maybe with its own .cfg) then the "base" package is the best place. If its multiple maps or a map with new media (textures etc.) its better to store it in its own package (a directory under "packages"), which makes distributing it less messy.')]),e._v(" "),a("h3",{attrs:{id:"newmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#newmap"}},[e._v("#")]),e._v(" newmap")]),e._v(" "),a("p",[a("code",[e._v("newmap size")])]),e._v(" "),a("p",[e._v("Creates a new map of size^2 cubes (on the smallest grid size). 10 is a small map, 15 is a large map but it goes up to 20.")]),e._v(" "),a("h3",{attrs:{id:"mapenlarge"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mapenlarge"}},[e._v("#")]),e._v(" mapenlarge")]),e._v(" "),a("p",[a("code",[e._v("mapenlarge")])]),e._v(" "),a("p",[e._v("Doubles the dimensions of the current map.")]),e._v(" "),a("h3",{attrs:{id:"maptitle"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#maptitle"}},[e._v("#")]),e._v(" maptitle")]),e._v(" "),a("p",[a("code",[e._v('maptitle "Title by Author"')])]),e._v(" "),a("p",[e._v('sets the map title, which will be displayed when the map loads. Either use the above format, or simply "by Author" if the map has no particular title (always displayed after the map load msg).')]),e._v(" "),a("h3",{attrs:{id:"loadsky"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loadsky"}},[e._v("#")]),e._v(" loadsky")]),e._v(" "),a("p",[a("code",[e._v("loadsky NAME [SPIN]")])]),e._v(" "),a("p",[e._v('loads the skybox described by NAME, where NAME is a file name relative to the "packages/" directory. The engine will look for 6 sky box images: NAME_up.jpg, NAME_dn.jpg, NAME_lf.jpg, NAME_rt.jpg, NAME_ft.jpg, NAME_bk.jpg. These represent the skybox in the up, down, left, right, front, and back directions, respectively. If a .jpg file is not found, it will attempt to search for the files with a .png extension. SPIN, if specified, is floating point value that specifies, in degrees per second, the rate at which to spin/yaw the skybox. NOTE: This is an alias for the "skybox" and "spinsky" commands.')]),e._v(" "),a("h3",{attrs:{id:"texturereset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#texturereset"}},[e._v("#")]),e._v(" texturereset")]),e._v(" "),a("p",[a("code",[e._v("texturereset")])]),e._v(" "),a("p",[e._v('Sets the texture slot to 0 for the subsequent "texture" commands.')]),e._v(" "),a("h3",{attrs:{id:"materialreset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#materialreset"}},[e._v("#")]),e._v(" materialreset")]),e._v(" "),a("p",[a("code",[e._v("materialreset")])]),e._v(" "),a("p",[e._v('Resets the material texture slots for subsequent "texture" commands.')]),e._v(" "),a("h3",{attrs:{id:"texture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#texture"}},[e._v("#")]),e._v(" texture")]),e._v(" "),a("p",[a("code",[e._v("texture TYPE FILENAME ROT X Y SCALE")])]),e._v(" "),a("h3",{attrs:{id:"autograss"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#autograss"}},[e._v("#")]),e._v(" autograss")]),e._v(" "),a("p",[a("code",[e._v("autograss FILENAME")])]),e._v(" "),a("p",[e._v("Automatically generates grass for the current texture slot on any upward facing surface. The grass texture FILENAME is used to to texture the grass blades.")]),e._v(" "),a("h3",{attrs:{id:"grassscale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#grassscale"}},[e._v("#")]),e._v(" grassscale")]),e._v(" "),a("p",[a("code",[e._v("grassscale N")])]),e._v(" "),a("p",[e._v("Sets the scaling of all grass textures to N where N=1..64 (default: 2).")]),e._v(" "),a("h3",{attrs:{id:"grasscolour"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#grasscolour"}},[e._v("#")]),e._v(" grasscolour")]),e._v(" "),a("p",[a("code",[e._v("grasscolour R G B")])]),e._v(" "),a("p",[e._v("The colour of the grass, specified as R G B values from 0..255 (default: 255 255 255).")]),e._v(" "),a("h3",{attrs:{id:"grassalpha"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#grassalpha"}},[e._v("#")]),e._v(" grassalpha")]),e._v(" "),a("p",[a("code",[e._v("grassalpha A")])]),e._v(" "),a("p",[e._v("Sets the opacity of all grass textures to A where floating point value A=0..1 (default: 1).")]),e._v(" "),a("h3",{attrs:{id:"texscroll"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#texscroll"}},[e._v("#")]),e._v(" texscroll")]),e._v(" "),a("p",[a("code",[e._v("texscroll X Y")])]),e._v(" "),a("p",[e._v("Scrolls the current texture slot at X and Y Hz, along the X and Y axes of the texture respectively.")]),e._v(" "),a("h3",{attrs:{id:"texrotate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#texrotate"}},[e._v("#")]),e._v(" texrotate")]),e._v(" "),a("p",[a("code",[e._v("texrotate N")])]),e._v(" "),a("p",[e._v("Rotates the current texture slot by N*90 degrees for N=0..3. N=4 flips along the X axis, and N=5 flips along the Y axis.")]),e._v(" "),a("h3",{attrs:{id:"vrotate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vrotate"}},[e._v("#")]),e._v(" vrotate")]),e._v(" "),a("p",[a("code",[e._v("vrotate N")])]),e._v(" "),a("p",[e._v('Rotates all textures in the current selection as if by the "texrotate" command.')]),e._v(" "),a("h3",{attrs:{id:"texoffset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#texoffset"}},[e._v("#")]),e._v(" texoffset")]),e._v(" "),a("p",[a("code",[e._v("texoffset X Y")])]),e._v(" "),a("p",[e._v("Offsets the current texture slot by X and Y texels along the X and Y axes of the texture respectively.")]),e._v(" "),a("h3",{attrs:{id:"voffset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#voffset"}},[e._v("#")]),e._v(" voffset")]),e._v(" "),a("p",[a("code",[e._v("voffset X Y")])]),e._v(" "),a("p",[e._v('Offsets all textures in the current selection as if by the "texoffset" command.')]),e._v(" "),a("h3",{attrs:{id:"texscale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#texscale"}},[e._v("#")]),e._v(" texscale")]),e._v(" "),a("p",[a("code",[e._v("texscale N")])]),e._v(" "),a("p",[e._v("Scales the current texture slot such that it is N times its normal size.")]),e._v(" "),a("h3",{attrs:{id:"vscale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vscale"}},[e._v("#")]),e._v(" vscale")]),e._v(" "),a("p",[a("code",[e._v("vscale N")])]),e._v(" "),a("p",[e._v('Scales all textures in the current selection as if by the "texscale" command.')]),e._v(" "),a("h3",{attrs:{id:"texalpha"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#texalpha"}},[e._v("#")]),e._v(" texalpha")]),e._v(" "),a("p",[a("code",[e._v("texalpha F B")])]),e._v(" "),a("p",[e._v("Sets the alpha transparency of the front faces to F and back faces to B, where F and B are floating point values in the range 0.0 to 1.0. F defaults to 0.5, and B defaults to 0 (invisible).")]),e._v(" "),a("h3",{attrs:{id:"valpha"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#valpha"}},[e._v("#")]),e._v(" valpha")]),e._v(" "),a("p",[a("code",[e._v("valpha F B")])]),e._v(" "),a("p",[e._v('Sets the alpha transparency of all textures in the current selection as if by the "texalpha" command.')]),e._v(" "),a("h3",{attrs:{id:"texcolor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#texcolor"}},[e._v("#")]),e._v(" texcolor")]),e._v(" "),a("p",[a("code",[e._v("texcolor R G B")])]),e._v(" "),a("p",[e._v("Sets the color multiplier of the current texture slot to the color R G B, where R, G, and B are floating point values in the range 0.0 to 1.0. The default is white, i.e. (1.0 1.0 1.0).")]),e._v(" "),a("h3",{attrs:{id:"vcolor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vcolor"}},[e._v("#")]),e._v(" vcolor")]),e._v(" "),a("p",[a("code",[e._v("vcolor R G B")])]),e._v(" "),a("p",[e._v('Sets the color multiplier of all textures in the current selection as if by the "texcolor" command.')]),e._v(" "),a("h3",{attrs:{id:"vreset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vreset"}},[e._v("#")]),e._v(" vreset")]),e._v(" "),a("p",[a("code",[e._v("vreset")])]),e._v(" "),a("p",[e._v("Resets the texture configuration of all textures in the current selection to the defaults defined in the map cfg file.")]),e._v(" "),a("h3",{attrs:{id:"vdelta"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vdelta"}},[e._v("#")]),e._v(" vdelta")]),e._v(" "),a("p",[a("code",[e._v("vdelta BODY")])]),e._v(" "),a("p",[e._v('Excutes all of the "v*" commands in BODY such that they now only add to the current values for the textures in the current selection, rather than simply setting them. For example, vdelta [vrotate 1] would add 1 to the current rotation value for the textures, rather than just setting their rotation value to 1. This affects the "vrotate" (adds), "voffset" (adds), "vscale" (multiplies), "vshaderparam" (overrides), and "vcolor" (multiplies) commands.')]),e._v(" "),a("h3",{attrs:{id:"fog"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fog"}},[e._v("#")]),e._v(" fog")]),e._v(" "),a("p",[a("code",[e._v("fog N")])]),e._v(" "),a("p",[e._v("Sets fog distance to N (default: 4000). You can do this for tweaking the visual effect of the fog, or if you are on a slow machine, setting the fog to a low value can also be a very effective way to increase fps (if you are geometry limited). Try out different values on big maps or maps which give you low fps.")]),e._v(" "),a("h3",{attrs:{id:"fogcolour"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fogcolour"}},[e._v("#")]),e._v(" fogcolour")]),e._v(" "),a("p",[a("code",[e._v("fogcolour R G B")])]),e._v(" "),a("p",[e._v("The colour of the fog, specified as R G B values from 0..255 (default: 128 153 179).")]),e._v(" "),a("h3",{attrs:{id:"waterspec"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#waterspec"}},[e._v("#")]),e._v(" waterspec")]),e._v(" "),a("p",[a("code",[e._v("waterspec N")])]),e._v(" "),a("p",[e._v("This sets the percentage of light water shows as specularity (default: 150).")]),e._v(" "),a("h3",{attrs:{id:"waterfog"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#waterfog"}},[e._v("#")]),e._v(" waterfog")]),e._v(" "),a("p",[a("code",[e._v("waterfog N")])]),e._v(" "),a("p",[e._v("Sets the distance beneath the surface of water at which it fogs, from 1..10000 (default: 150).")]),e._v(" "),a("h3",{attrs:{id:"watercolour"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watercolour"}},[e._v("#")]),e._v(" watercolour")]),e._v(" "),a("p",[a("code",[e._v("watercolour R G B")])]),e._v(" "),a("p",[e._v("Sets the the colour of fog inside the water to the specified R G B value from 0..255 (default: 20 70 80). Used to give water some colour. Setting to the values 0 0 0 will cause it to reset to the default watercolour.")]),e._v(" "),a("h3",{attrs:{id:"waterfallcolour"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#waterfallcolour"}},[e._v("#")]),e._v(" waterfallcolour")]),e._v(" "),a("p",[a("code",[e._v("waterfallcolour R G B")])]),e._v(" "),a("p",[e._v('Sets the the colour used for waterfall turbulence to the specified R G B value from 0..255 (default: 0 0 0). If the default of 0 0 0 is specified, waterfalls will use the colour supplied via "watercolour" instead.')]),e._v(" "),a("h3",{attrs:{id:"lavafog"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lavafog"}},[e._v("#")]),e._v(" lavafog")]),e._v(" "),a("p",[a("code",[e._v("lavafog N")])]),e._v(" "),a("p",[e._v("Sets the distance beneath the surface of lava at which it fogs, from 1..10000 (default: 50).")]),e._v(" "),a("h3",{attrs:{id:"lavacolour"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lavacolour"}},[e._v("#")]),e._v(" lavacolour")]),e._v(" "),a("p",[a("code",[e._v("lavacolour R G B")])]),e._v(" "),a("p",[e._v("Sets the the colour of fog inside the lava to the specified R G B value from 0..255 (default: 255 64 0). Used to give lava some colour. Setting to the values 0 0 0 will cause it to reset to the default watercolour.")]),e._v(" "),a("h3",{attrs:{id:"shader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shader"}},[e._v("#")]),e._v(" shader")]),e._v(" "),a("p",[a("code",[e._v("shader TYPE NAME VS PS")])]),e._v(" "),a("p",[e._v("defines a shader NAME with vertex shader VS and pixel shader PS (both in ARB OpenGL 1.5 assembly format). See data/stdshader.cfg for examples. These definitions can be put in map cfg files or anywhere else, and will only be compiled once. TYPE indicates what resources the shader provides, or what backup method should be used if the graphics card does not support shaders. TYPE is either 0 for default shader, or 1 for normal-mapped world shaders. Requires DX9 / shader 2 class hardware (radeon 9500 or better, geforce 5200 or better) to run (older hardware will default to basic rendering).")]),e._v(" "),a("h3",{attrs:{id:"fastshader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fastshader"}},[e._v("#")]),e._v(" fastshader")]),e._v(" "),a("p",[a("code",[e._v("fastshader NICE FAST N")])]),e._v(" "),a("p",[e._v("Associates shader FAST so that it will run in place of shader NICE if shaderdetail is less than or equal to N.")]),e._v(" "),a("h3",{attrs:{id:"setshader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setshader"}},[e._v("#")]),e._v(" setshader")]),e._v(" "),a("p",[a("code",[e._v("setshader NAME")])]),e._v(" "),a("p",[e._v('Sets a previously defined shader as the current shader. Any following texture slots (see "texture" command) will have this shader attached to them. Any pixel or vertex parameters are reset to the shader\'s defaults when this command is used.')]),e._v(" "),a("h3",{attrs:{id:"setshaderparam"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setshaderparam"}},[e._v("#")]),e._v(" setshaderparam")]),e._v(" "),a("p",[a("code",[e._v("setshaderparam NAME X Y Z W")])]),e._v(" "),a("p",[e._v("Overrides a uniform parameter for the current shader. Any following texture slots will use this pixel parameter until its value is set/reset by subsequent commands. NAME is the name of a defined parameter of the current shader. It's value is set to the vector (X, Y, Z, W). Coordinates that are not specified default to 0.")]),e._v(" "),a("h3",{attrs:{id:"vshaderparam"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vshaderparam"}},[e._v("#")]),e._v(" vshaderparam")]),e._v(" "),a("p",[a("code",[e._v("vshaderparam NAME X Y Z W")])]),e._v(" "),a("p",[e._v('Overrides a uniform parameter for the shaders of all textures in the current selection, as if by the "setshaderparam" command.')]),e._v(" "),a("h3",{attrs:{id:"setpixelparam"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setpixelparam"}},[e._v("#")]),e._v(" setpixelparam")]),e._v(" "),a("p",[a("code",[e._v("setpixelparam INDEX X Y Z W")])]),e._v(" "),a("p",[e._v("Overrides a pixel parameter for the current shader. Any following texture slots will use this pixel parameter until its value is set/reset by subsequent commands. INDEX is the index of a program environment parameter (program.env[10+INDEX]) to the pixel program of the current shader. It's value is set to the vector (X, Y, Z, W). Coordinates that are not specified default to 0.")]),e._v(" "),a("h3",{attrs:{id:"setvertexparam"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setvertexparam"}},[e._v("#")]),e._v(" setvertexparam")]),e._v(" "),a("p",[a("code",[e._v("setvertexparam INDEX X Y Z W")])]),e._v(" "),a("p",[e._v("Overrides a vertex parameter for the current shader. Any following texture slots will use this vertex parameter until its value is set/reset by subsequent commands. INDEX is the index of a program environment parameter (program.env[10+INDEX]) to the vertex program of the current shader. It's value is set to the vector (X, Y, Z, W). Coordinates that are not specified default to 0.")]),e._v(" "),a("h3",{attrs:{id:"setuniformparam"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setuniformparam"}},[e._v("#")]),e._v(" setuniformparam")]),e._v(" "),a("p",[a("code",[e._v("setuniformparam NAME X Y Z W")])]),e._v(" "),a("p",[e._v("Overrides a uniform parameter for the current shader. Any following texture slots will use this pixel parameter until its value is set/reset by subsequent commands. NAME is the name of a uniform variable in the current GLSL shader. It's value is set to the vector (X, Y, Z, W). Coordinates that are not specified default to 0.")]),e._v(" "),a("h3",{attrs:{id:"music"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#music"}},[e._v("#")]),e._v(" music")]),e._v(" "),a("p",[a("code",[e._v("music name [ondone]")])]),e._v(" "),a("p",[e._v('Plays song "name" (with "packages" as base dir). This command is best used from map cfg files or triggers. Evaluates ondone when the song is finished, or just keeps looping the song if ondone is missing. Example: music "songs/music.ogg" [ echo "Song done playing!" ]')]),e._v(" "),a("h3",{attrs:{id:"registersound"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#registersound"}},[e._v("#")]),e._v(" registersound")]),e._v(" "),a("p",[a("code",[e._v("N = registersound name V")])]),e._v(" "),a("p",[e._v('Registers sound "name" (see for example data/sounds.cfg). This command returns the sound number N, which is assigned from 0 onwards, and which can be used with "sound" command below. if the sound was already registered, its existing index is returned. registersound does not actually load the sound, this is done on first play. V is volume adjustment; if not specified (0), it is the default 100, valid range is 1-255.')]),e._v(" "),a("h3",{attrs:{id:"sound"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sound"}},[e._v("#")]),e._v(" sound")]),e._v(" "),a("p",[a("code",[e._v("sound N")])]),e._v(" "),a("p",[e._v('Plays sound N, see data/sounds.cfg for default sounds, and use registersound to register your own. for example, sound 0 and sound (registersound "aard/jump") both play the standard jump sound.')]),e._v(" "),a("h3",{attrs:{id:"mapsound"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mapsound"}},[e._v("#")]),e._v(" mapsound")]),e._v(" "),a("p",[a("code",[e._v("mapsound name V N")])]),e._v(" "),a("p",[e._v('Registers sound "name" as a map-specific sounds. These map-specific sounds may currently only be used with "sound" entities within a map. The first map sound registered in a map has index 0, and increases afterwards (the second sound in the config is 1 and the third is 2, and so on). V is volume adjustment; if not specified (0), it is the default 100, valid range is 1-255. N is the maximum number instances of this sound that are allowed to play simultaneously; the default is only 1 instance. If N is -1, then an unlimited number of instances may play simultaneously.')]),e._v(" "),a("h3",{attrs:{id:"mmodel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mmodel"}},[e._v("#")]),e._v(" mmodel")]),e._v(" "),a("p",[a("code",[e._v("mmodel S")])]),e._v(" "),a("p",[e._v("N is the name of a folder inside packages/models folder, this will look for a .cfg (config) file with the 3D mapmodel format name (obj.cfg, md2.cfg, md3.cfg, md5.cfg, iqm.cfg)")]),e._v(" "),a("p",[e._v("Example: mmodel snoutx10k")]),e._v(" "),a("h3",{attrs:{id:"shadowmapambient"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shadowmapambient"}},[e._v("#")]),e._v(" shadowmapambient")]),e._v(" "),a("p",[a("code",[e._v("shadowmapambient N")])]),e._v(" "),a("p",[e._v('specifies a colour to use for the ambient light value of shadows created by shadowmapping, where N is a hexadecimal colour value of the form "0xRRGGBB". Note that any value of 255 or less are treated as gray-scale. If N is 0 or unset, this value is determined by the "ambient" variable and the "skylight" command. (Default: 0)')]),e._v(" "),a("h3",{attrs:{id:"shadowmapangle"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shadowmapangle"}},[e._v("#")]),e._v(" shadowmapangle")]),e._v(" "),a("p",[a("code",[e._v("shadowmapangle N")])]),e._v(" "),a("p",[e._v("specifies the angle in degrees at which shadows created by shadowmapping point. If N is 0 or unset, this value is guessed based on any radius 0 lights in the map.")]),e._v(" "),a("h3",{attrs:{id:"causticscale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#causticscale"}},[e._v("#")]),e._v(" causticscale")]),e._v(" "),a("p",[a("code",[e._v("causticscale N")])]),e._v(" "),a("p",[e._v("specifies the scale, as a percent, to multiply the size of water caustics by.")]),e._v(" "),a("h3",{attrs:{id:"causticmillis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#causticmillis"}},[e._v("#")]),e._v(" causticmillis")]),e._v(" "),a("p",[a("code",[e._v("causticmillis N")])]),e._v(" "),a("p",[e._v("specifies the speed at which water caustics play, in milliseconds per frame.")]),e._v(" "),a("h3",{attrs:{id:"skybox"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#skybox"}},[e._v("#")]),e._v(" skybox")]),e._v(" "),a("p",[a("code",[e._v("skybox NAME")])]),e._v(" "),a("p",[e._v('loads the skybox described by NAME, where NAME is a file name relative to the "packages/" directory. The engine will look for 6 sky box images: NAME_up.jpg, NAME_dn.jpg, NAME_lf.jpg, NAME_rt.jpg, NAME_ft.jpg, NAME_bk.jpg. These represent the skybox in the up, down, left, right, front, and back directions, respectively. If a .jpg file is not found, it will attempt to search for the files with a .png extension.')]),e._v(" "),a("h3",{attrs:{id:"spinsky"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spinsky"}},[e._v("#")]),e._v(" spinsky")]),e._v(" "),a("p",[a("code",[e._v("spinsky SPIN")])]),e._v(" "),a("p",[e._v("a floating point value that specifies, in degrees per second, the rate at which to spin/yaw the skybox.")]),e._v(" "),a("h3",{attrs:{id:"yawsky"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#yawsky"}},[e._v("#")]),e._v(" yawsky")]),e._v(" "),a("p",[a("code",[e._v("yawsky YAW")])]),e._v(" "),a("p",[e._v("specifies in degrees a constant yaw rotation to apply to the skybox.")]),e._v(" "),a("h3",{attrs:{id:"cloudbox"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cloudbox"}},[e._v("#")]),e._v(" cloudbox")]),e._v(" "),a("p",[a("code",[e._v("cloudbox NAME")])]),e._v(" "),a("p",[e._v('loads the cloudbox described by NAME, similar to the "skybox" command. The cloudbox should have an alpha channel which is used to blend it over the normal skybox.')]),e._v(" "),a("h3",{attrs:{id:"spinclouds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spinclouds"}},[e._v("#")]),e._v(" spinclouds")]),e._v(" "),a("p",[a("code",[e._v("spinclouds SPIN")])]),e._v(" "),a("p",[e._v("a floating point value that specifies, in degrees per second, the rate at which to spin/yaw the cloudbox.")]),e._v(" "),a("h3",{attrs:{id:"yawclouds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#yawclouds"}},[e._v("#")]),e._v(" yawclouds")]),e._v(" "),a("p",[a("code",[e._v("yawclouds YAW")])]),e._v(" "),a("p",[e._v("specifies in degrees a constant yaw rotation to apply to the cloudbox.")]),e._v(" "),a("h3",{attrs:{id:"cloudclip"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cloudclip"}},[e._v("#")]),e._v(" cloudclip")]),e._v(" "),a("p",[a("code",[e._v("cloudclip CLIP")])]),e._v(" "),a("p",[e._v("specifies a vertical offset at which to clip the cloudbox, a floating point value between 0 and 1. This defaults to 0.5, meaning the bottom half of the cloudbox is clipped away.")]),e._v(" "),a("h3",{attrs:{id:"cloudlayer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cloudlayer"}},[e._v("#")]),e._v(" cloudlayer")]),e._v(" "),a("p",[a("code",[e._v("cloudlayer NAME")])]),e._v(" "),a("p",[e._v('loads the cloud layer described by NAME, where NAME is a file name relative to the "packages/" directory. The engine will look for either "packages/NAME.png" or "packages/NAME.jpg". The cloud layer should have an alpha channel which is used to blend it onto the skybox. The cloud layer is mapped onto a horizontal circle that fades into the edges of the skybox.')]),e._v(" "),a("h3",{attrs:{id:"cloudscrollx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cloudscrollx"}},[e._v("#")]),e._v(" cloudscrollx")]),e._v(" "),a("p",[a("code",[e._v("cloudscrollx N")])]),e._v(" "),a("p",[e._v("specifies the rate, a floating-point value in Hz, at which the cloud layer scrolls in the X direction.")]),e._v(" "),a("h3",{attrs:{id:"cloudscrolly"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cloudscrolly"}},[e._v("#")]),e._v(" cloudscrolly")]),e._v(" "),a("p",[a("code",[e._v("cloudscrolly N")])]),e._v(" "),a("p",[e._v("specifies the rate, a floating-point value in Hz, at which the cloud layer scrolls in the Y direction.")]),e._v(" "),a("h3",{attrs:{id:"cloudscale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cloudscale"}},[e._v("#")]),e._v(" cloudscale")]),e._v(" "),a("p",[a("code",[e._v("cloudscale N")])]),e._v(" "),a("p",[e._v("specifies the scale as a floating-point value telling how much to multiply the size of the cloud layer. (Default: 1)")]),e._v(" "),a("h3",{attrs:{id:"cloudheight"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cloudheight"}},[e._v("#")]),e._v(" cloudheight")]),e._v(" "),a("p",[a("code",[e._v("cloudheight N")])]),e._v(" "),a("p",[e._v("specifies the height of the cloud layer as a floating-point value, where -1 corresponds to the bottom of the skybox, 0 corresponds to the middle of the skybox, and 1 corresponds to the top of the skybox. Intermediate values place the cloud layer at intermediate heights of those. (Default: 0.2)")]),e._v(" "),a("h3",{attrs:{id:"cloudfade"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cloudfade"}},[e._v("#")]),e._v(" cloudfade")]),e._v(" "),a("p",[a("code",[e._v("cloudfade N")])]),e._v(" "),a("p",[e._v("specifies the offset towards the center of the cloud layer at which the cloud layer will start fading into the skybox. This is a floating-point value between 0 and 1, where 0 corresponds to the edge of the cloud layer, and 1 corresponds to the center. (Default: 0.2)")]),e._v(" "),a("h3",{attrs:{id:"cloudcolour"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cloudcolour"}},[e._v("#")]),e._v(" cloudcolour")]),e._v(" "),a("p",[a("code",[e._v("cloudcolour R G B")])]),e._v(" "),a("p",[e._v("specifies a colour multiplier for the cloud layer as R G B values from 0..255.")]),e._v(" "),a("h3",{attrs:{id:"cloudalpha"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cloudalpha"}},[e._v("#")]),e._v(" cloudalpha")]),e._v(" "),a("p",[a("code",[e._v("cloudalpha F")])]),e._v(" "),a("p",[e._v("specifies an opacity for the cloud layer, where F is a floating-point value between 0 and 1. (Default: 1, solid)")]),e._v(" "),a("h3",{attrs:{id:"fogdomeheight"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fogdomeheight"}},[e._v("#")]),e._v(" fogdomeheight")]),e._v(" "),a("p",[a("code",[e._v("fogdomeheight F")])]),e._v(" "),a("p",[e._v("specifies the height of the fog dome as a floating-point value, where -1 corresponds to the bottom of the skybox, 0 corresponds to the middle of the skybox, and 1 corresponds to the top of the skybox. Intermediate values place the fog dome at intermediate heights of those. (Default: -0.5)")]),e._v(" "),a("h3",{attrs:{id:"fogdomemin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fogdomemin"}},[e._v("#")]),e._v(" fogdomemin")]),e._v(" "),a("p",[a("code",[e._v("fogdomemin F")])]),e._v(" "),a("p",[e._v("specifies a minimum opacity for the fog dome, where F is a floating-point value between 0 and 1. (Default: 0, invisible)")]),e._v(" "),a("h3",{attrs:{id:"fogdomemax"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fogdomemax"}},[e._v("#")]),e._v(" fogdomemax")]),e._v(" "),a("p",[a("code",[e._v("fogdomemax F")])]),e._v(" "),a("p",[e._v("specifies a maximum opacity for the fog dome, where F is a floating-point value between 0 and 1. (Default: 0, invisible)")]),e._v(" "),a("h3",{attrs:{id:"fogdomecap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fogdomecap"}},[e._v("#")]),e._v(" fogdomecap")]),e._v(" "),a("p",[a("code",[e._v("fogdomecap B")])]),e._v(" "),a("p",[e._v("specifies whether the bottom of the fog dome should be capped, where B is 0 or 1 (Default: 1, on).")]),e._v(" "),a("h3",{attrs:{id:"fogdomeclip"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fogdomeclip"}},[e._v("#")]),e._v(" fogdomeclip")]),e._v(" "),a("p",[a("code",[e._v("fogdomeclip F")])]),e._v(" "),a("p",[e._v("specifies whether the top of the fog dome should be clipped off at a relative size F, where F is a floating-point value between 0 and 1 (Default: 1, not clipped).")]),e._v(" "),a("h3",{attrs:{id:"fogdomecolour"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fogdomecolour"}},[e._v("#")]),e._v(" fogdomecolour")]),e._v(" "),a("p",[a("code",[e._v("fogdomecolour R G B")])]),e._v(" "),a("p",[e._v("The colour of the fog dome, specified as R G B values from 0..255 (default: 0 0 0). If the colour is 0, then the value of fogcolour is used instead of fogdomecolour.")]),e._v(" "),a("h3",{attrs:{id:"skytexture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#skytexture"}},[e._v("#")]),e._v(" skytexture")]),e._v(" "),a("p",[a("code",[e._v("skytexture B")])]),e._v(" "),a("p",[e._v('specifies whether or not to enable rendering of sky-textured surfaces. If set to 0, sky-textured surfaces are not rendered, allowing sky texture to be used as a "don\'t render this" surface. Disabling this also allows the skybox to be rendered last after the scene, which yields speedups on some video cards, so disable this if possible in your map, even though it defaults to on. (Default: 1)')]),e._v(" "),a("h3",{attrs:{id:"importcube"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#importcube"}},[e._v("#")]),e._v(" importcube")]),e._v(" "),a("p",[a("code",[e._v("importcube S")])]),e._v(" "),a("p",[e._v("Imports a cube map (.cgz) and converts it to the OCTA (.ogz) map format. S is the name of the map, without the .cgz. The map file must reside in packages/cube, which is because that folder has a package.cfg that sets the default cube textures. If the cube map in question has a custom texture list, it will have to be adapted manually. Currently converts everything relatively faithfully, except heighfields which are converted as best as possible but not always accurately. Slopes tend to work faultlessly, landscape style stuff is usuable, but curves/arches are problematic, and may have to be redone. All entities are converted though mapmodels may not be present, and light entities are useless because of their 2d nature, so probably the first thing to do after converting a map is /clearents light, and place some new lights. Pickups and other items may spawn inside the walls because they have no proper Z value, you may have to correct these manually. The importcube command does not automatically save the map, you still have to do a /savecurrentmap which will create packages/cube/N.ogz. Reload the map to be able to pick up stuff. Waterlevel is also not supported, you will have to add water using the material system.")]),e._v(" "),a("h3",{attrs:{id:"writeobj"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#writeobj"}},[e._v("#")]),e._v(" writeobj")]),e._v(" "),a("p",[a("code",[e._v("writeobj S")])]),e._v(" "),a("p",[e._v("Writes out the current map as S.obj, so you could use the engine as a generic modeller with any program/engine that uses meshes. The meshes aren't very optimal and don't have lighting information.")]),e._v(" "),a("h3",{attrs:{id:"flipnormalmapy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flipnormalmapy"}},[e._v("#")]),e._v(" flipnormalmapy")]),e._v(" "),a("p",[a("code",[e._v("flipnormalmapy D N")])]),e._v(" "),a("p",[e._v("Normalmaps generally come in two kinds, left-handed or righ-handed coordinate systems. If you are trying to use normalmaps authored for other engines, you may find that the lighting goes the wrong way along one axis, this can be fixed by flipping the Y coordinate of the normal. This command loads normalmap N (MUST be 24bit .tga), and writes out a flipped normalmap as D (also tga).")]),e._v(" "),a("h3",{attrs:{id:"mergenormalmaps"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mergenormalmaps"}},[e._v("#")]),e._v(" mergenormalmaps")]),e._v(" "),a("p",[a("code",[e._v("mergenormalmaps H N")])]),e._v(" "),a("p",[e._v("Normalmaps authored for Quake 4 often come as a base normal map, with seperate height offset file *_h.tga. This is NOT a height file as used for parallax, instead its detail to be blended onto the normals. This command takes normalmap N and a _h file H (both MUST be 24bit .tga), and outputs a combined normalmap N (it "),a("em",[e._v("overwrites")]),e._v(" N).")]),e._v(" "),a("h2",{attrs:{id:"lighting"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lighting"}},[e._v("#")]),e._v(" Lighting")]),e._v(" "),a("h3",{attrs:{id:"ambient"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ambient"}},[e._v("#")]),e._v(" ambient")]),e._v(" "),a("p",[a("code",[e._v("ambient R [G B]")])]),e._v(" "),a("p",[e._v("This sets the level of ambient light (default: 25), where R G B are color values 0..255. If only R is specified, it is interpreted as a grayscale light value. This is the minimum amount of light that a surface will get, even when no light entities reach the surface.")]),e._v(" "),a("h3",{attrs:{id:"edgetolerance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#edgetolerance"}},[e._v("#")]),e._v(" edgetolerance")]),e._v(" "),a("p",[a("code",[e._v("edgetolerance N")])]),e._v(" "),a("p",[e._v("This controls how far an intersection with some geometry has to be from the surface of the actual triangle in question before it counts as a shadow (default: 4), where N is 1..8; the distance immediately in front of the triangle along the edge where it ignores shadows.")]),e._v(" "),a("p",[e._v("When lighting a map, each lightmap pixel is the result of many samples from a grid-pattern, as a result the sampling pattern may go over the edge of one triangle but behind another. Increasing this variable helps alleviate this, especially in terrain heavy maps.")]),e._v(" "),a("h3",{attrs:{id:"sunlight"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sunlight"}},[e._v("#")]),e._v(" sunlight")]),e._v(" "),a("p",[a("code",[e._v("sunlight R [G B]")])]),e._v(" "),a("p",[e._v('This sets the color of a simple directional sunlight. R G B are values in the range 0..255 (default: 0). If only R, is specified it is interpreted as a grayscale light value. Use "sunlight 0" to disable.')]),e._v(" "),a("h3",{attrs:{id:"sunlightyaw"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sunlightyaw"}},[e._v("#")]),e._v(" sunlightyaw")]),e._v(" "),a("p",[a("code",[e._v("sunlightyaw YAW")])]),e._v(" "),a("p",[e._v("This sets the yaw of the directional sunlight to YAW.")]),e._v(" "),a("h3",{attrs:{id:"sunlightpitch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sunlightpitch"}},[e._v("#")]),e._v(" sunlightpitch")]),e._v(" "),a("p",[a("code",[e._v("sunlightpitch PITCH")])]),e._v(" "),a("p",[e._v("This sets the pitch of the directional sunlight to PITCH.")]),e._v(" "),a("h3",{attrs:{id:"sunlightscale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sunlightscale"}},[e._v("#")]),e._v(" sunlightscale")]),e._v(" "),a("p",[a("code",[e._v("sunlightscale F")])]),e._v(" "),a("p",[e._v("This sets the color scale of the direction sunlight to the floating-point value F (default: 1.0).")]),e._v(" "),a("h3",{attrs:{id:"skylight"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#skylight"}},[e._v("#")]),e._v(" skylight")]),e._v(" "),a("p",[a("code",[e._v("skylight R [G B]")])]),e._v(" "),a("p",[e._v('This enables the skybox to "emit" light, that can be occluded by geometry or models in the map. A surface will cast a number of rays (currently 17), and any of them that hit the skybox will contribute a portion of the R G B light value above the "ambient" level to the surface (1/17th of the light). Effectively, the light will vary between the "ambient" value and the "skylight" value depending on how much of the skybox is visible. R G B are values in the range 0..255 (default: 0). If only R, is specified it is interpreted as a grayscale light value. Use "skylight 0" to disable.')]),e._v(" "),a("h3",{attrs:{id:"lmshadows"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lmshadows"}},[e._v("#")]),e._v(" lmshadows")]),e._v(" "),a("p",[a("code",[e._v("lmshadows N")])]),e._v(" "),a("p",[e._v('This controls the level of shadowing used when "calclight" or "patchlight" are not given a quality setting, where N is:')]),e._v(" "),a("ul",[a("li",[e._v("2 (default): world and mapmodel shadows")]),e._v(" "),a("li",[e._v("1: world shadows only")]),e._v(" "),a("li",[e._v("0: no shadows")])]),e._v(" "),a("h3",{attrs:{id:"lmaa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lmaa"}},[e._v("#")]),e._v(" lmaa")]),e._v(" "),a("p",[a("code",[e._v("lmaa N")])]),e._v(" "),a("p",[e._v('This controls the level of anti-aliasing used when "calclight" or "patchlight" are not given a quality setting, where N is:')]),e._v(" "),a("ul",[a("li",[e._v("3 (default): 8xAA")]),e._v(" "),a("li",[e._v("2: 4xAA")]),e._v(" "),a("li",[e._v("1: 2xAA")]),e._v(" "),a("li",[e._v("0: no AA")])]),e._v(" "),a("h3",{attrs:{id:"calclight"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#calclight"}},[e._v("#")]),e._v(" calclight")]),e._v(" "),a("p",[a("code",[e._v("calclight Q")])]),e._v(" "),a("p",[e._v('This calculates all lightmaps. Usually takes only a few seconds, depending on map size and settings. If you "savemap", the lightmap will be stored along with it. Q is these predefined quality settings:')]),e._v(" "),a("ul",[a("li",[e._v("1: 8x anti aliasing, world and mapmodel shadows (maximum quality, slow)")]),e._v(" "),a("li",[e._v('0 or not given: controlled by "lmshadows" and "lmaa" values')]),e._v(" "),a("li",[e._v("-1: no anti aliasing, world shadows only (low quality, good for lighting previews)")])]),e._v(" "),a("h3",{attrs:{id:"patchlight"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#patchlight"}},[e._v("#")]),e._v(" patchlight")]),e._v(" "),a("p",[a("code",[e._v("patchlight Q")])]),e._v(" "),a("p",[e._v('This will calculate lightmaps for any newly created cubes. This will generally be much quicker than doing a "calclight", and so is very useful when editing. However, it will make very inefficient use of lightmap textures, and any new cubes will not properly cast shadows on surfaces that are already lit. It is recommended you do a "calclight" on your map before you publish it with "savemap". A quality setting Q may be supplied, which behaves the same as for "calclight".')]),e._v(" "),a("h3",{attrs:{id:"lightthreads"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lightthreads"}},[e._v("#")]),e._v(" lightthreads")]),e._v(" "),a("p",[a("code",[e._v("lightthreads N")])]),e._v(" "),a("p",[e._v('This controls the number of threads (N) used by the "calclight" and "patchlight" commands You should set this variable to the number of processor cores you have to get a speed-up. By default (N=1), no multi-threading is used.')]),e._v(" "),a("h3",{attrs:{id:"fullbright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fullbright"}},[e._v("#")]),e._v(" fullbright")]),e._v(" "),a("p",[a("code",[e._v("fullbright B")])]),e._v(" "),a("p",[e._v("This variable controls whether the map will be shown with lighting disabled. Fullbright 1 will disable lighting, whereas 0 will enable lighting. (Default = 0)")]),e._v(" "),a("h3",{attrs:{id:"lerpangle"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lerpangle"}},[e._v("#")]),e._v(" lerpangle")]),e._v(" "),a("p",[a("code",[e._v("lerpangle A")])]),e._v(" "),a("p",[e._v("Default = 44. This variable controls whether surface normals are interpolated for lighting. Normals are sampled at each vertex of the surface. If the angle between two surfaces' normals (which meet at a vertex) is less than A, then the resulting normal will be the average of the two. Normals are then later interpolated between the normals at the vertexes of a surface.")]),e._v(" "),a("h3",{attrs:{id:"lerpsubdiv"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lerpsubdiv"}},[e._v("#")]),e._v(" lerpsubdiv")]),e._v(" "),a("p",[a("code",[e._v("lerpsubdiv N")])]),e._v(" "),a("p",[e._v("Default = 2. This allows more normals to be sampled at points along an edge between two vertexes of a surface. 2^N-1 extra normals will be sampled along the edge, i.e. the edge is split in half for every increment of N.")]),e._v(" "),a("h3",{attrs:{id:"lerpsubdivsize"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lerpsubdivsize"}},[e._v("#")]),e._v(" lerpsubdivsize")]),e._v(" "),a("p",[a("code",[e._v("lerpsubdivsize N")])]),e._v(" "),a("p",[e._v("Default = 4. This sets the minimum size to which an edge may be subdivided. Edges smaller than N or edge sections smaller than N will not be sampled.")]),e._v(" "),a("h3",{attrs:{id:"lightprecision"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lightprecision"}},[e._v("#")]),e._v(" lightprecision")]),e._v(" "),a("p",[a("code",[e._v("lightprecision P")])]),e._v(" "),a("p",[e._v("Default = 32. This is the most important variable for tweaking the lighting, it determines what the resolution of the lightmap is. As such has a BIG effect on calculation time, video memory usage, and map file size. The default is good for most maps, you may go as low as 16 if you are lighting a really small map and love hard shadows, and for bigger maps you may need to set it to 64 or so to get reasonable memory usage.")]),e._v(" "),a("p",[e._v("The number to watch out for is the number of lightmaps generated which are shown on the HUD (and also as output after a calclight). 1 or 2 lightmap textures is very good, over 10 lightmap textures is excessive.")]),e._v(" "),a("p",[e._v("The map file size is 90% determined by the lightmaps, so tweak this value to get an acceptable quality to size ratio. Look at the size of the map files, sometimes a slightly higher lightprecision can halve the size of your .ogz.")]),e._v(" "),a("p",[e._v("Every surface matters, even though the engine attempts to compress surfaces with a uniform lightvalue, it is always a good ideas to delete parts of the world that are not part of your map. Lightprecision, lighterror, and lightlod are stored as part of map files.")]),e._v(" "),a("h3",{attrs:{id:"lighterror"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lighterror"}},[e._v("#")]),e._v(" lighterror")]),e._v(" "),a("p",[a("code",[e._v("lighterror E")])]),e._v(" "),a("p",[e._v("There should be little reason to tweak this. If in your map you can see visible polygon boundaries caused by lighting, you can try stepping this down to 6 or 4 to improve quality at the expense of lightmap space. If you have an insanely large map and looking for ways to reduce file size, increasing error up to 16 may help. (Default = 8)")]),e._v(" "),a("h3",{attrs:{id:"lightlod"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lightlod"}},[e._v("#")]),e._v(" lightlod")]),e._v(" "),a("p",[a("code",[e._v("lightlod D")])]),e._v(" "),a("p",[e._v("Default = 0. This will double the resolution of lightmaps (cut the lightprecision in half) if size of the surface being lit is smaller than 2^D units. This allows large maps to have pockets of detailed lighting without using a high resolution over everything. NOTE: if you feel like using this, test it thoroughly. On medium or small sized detailed maps, this command wastes space, use lightlod 0. Lightlod > 0 is only useful for huge maps")]),e._v(" "),a("h3",{attrs:{id:"blurlms"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blurlms"}},[e._v("#")]),e._v(" blurlms")]),e._v(" "),a("p",[a("code",[e._v("blurlms N")])]),e._v(" "),a("p",[e._v("This variable controls whether to apply a blur filter to the lightmap after they are generated, as a post-pass. For N=0, no blur is applied. For N=1, a 3x3 blur filter is used. For N=2, a 5x5 blur filter is used. NOTE: this can cause lightmaps to mismatch at surface boundaries in complex scenes.")]),e._v(" "),a("h3",{attrs:{id:"blurskylight"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blurskylight"}},[e._v("#")]),e._v(" blurskylight")]),e._v(" "),a("p",[a("code",[e._v("blurskylight N")])]),e._v(" "),a("p",[e._v('This variable controls whether to apply a blur filter to the ambient skylight (enabled via the "skylight" command) before it is combined with the other lighting to create the final lightmap. This variable is useful for softening the skylight and making it appear more scattered. For N=0, no blur is applied. For N=1, a 3x3 blur filter is used. For N=2, a 5x5 blur filter is used.')]),e._v(" "),a("h3",{attrs:{id:"dumplms"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dumplms"}},[e._v("#")]),e._v(" dumplms")]),e._v(" "),a("p",[a("code",[e._v("dumplms")])]),e._v(" "),a("p",[e._v("Dumps all lightmaps to a set of .bmps. Mostly interesting for developers, but mappers may find it interesting too.")]),e._v(" "),a("h2",{attrs:{id:"texture-blending"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#texture-blending"}},[e._v("#")]),e._v(" Texture Blending")]),e._v(" "),a("p",[e._v("Texture blending in maps is accomplished by smoothly blending two textures together to create variations on architecture and terrain.")]),e._v(" "),a("p",[e._v("Texture blending can use any two textures that are already set in your map.cfg, but you need to define the textures normally first. Texture thumbnails that have an additional texture layer to blend will have the texture they are set to blend with in one of the corners in the texture browser (f2).")]),e._v(" "),a("p",[e._v("To set up textures to blend, in your map cfg, under the texture that you want to have a second texture layer, you would add:")]),e._v(" "),a("h3",{attrs:{id:"texlayer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#texlayer"}},[e._v("#")]),e._v(" texlayer")]),e._v(" "),a("p",[a("code",[e._v("texlayer N")])]),e._v(" "),a("p",[e._v("N is the index of the texture slot you want to use as the bottom texture layer to blend with. Texture slots start at 0, which is the first slot, 1 is the second slot, 2 is the third slot, etc. If N is a negative number, it will reference N slots back from the current slot, i.e. -1 references the previous texture slot.")]),e._v(" "),a("h3",{attrs:{id:"vlayer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vlayer"}},[e._v("#")]),e._v(" vlayer")]),e._v(" "),a("p",[a("code",[e._v("vlayer N")])]),e._v(" "),a("p",[e._v('Sets the bottom texture layer for all textures in the current selection, as if by "texlayer" command. However, negative values of N are not supported.')]),e._v(" "),a("p",[e._v('There will be a number of brushes already included and set up in the default "data/brush.cfg". If you want to set up your own brush, create a grayscale PNG file to use as a pattern. Keep in mind that the size of the brushes are relatively large, and not meant for super detailed work. So a 16 x 16 size image will make a brush that covers a very large patch of architecture.')]),e._v(" "),a("h3",{attrs:{id:"addblendbrush"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#addblendbrush"}},[e._v("#")]),e._v(" addblendbrush")]),e._v(" "),a("p",[a("code",[e._v("addblendbrush N F")])]),e._v(" "),a("p",[e._v('Where N is the name of your brush, that you will use later to load the brush, and F is the file name, relative to the data directory. So if the brush you want to add is called "mybrush.png", then you would add the following line to your map.cfg file: addblendbrush mybrush "mybrush.png"". Note that the filename of the brush image is relative to the root directory.')]),e._v(" "),a("h3",{attrs:{id:"setblendbrush"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setblendbrush"}},[e._v("#")]),e._v(" setblendbrush")]),e._v(" "),a("p",[a("code",[e._v("setblendbrush N")])]),e._v(" "),a("p",[e._v("Where N is the name of your brush that you defined in the cfg, or the name of an existing brush. So to set the brush to the one that was defined above, you would open the console with the tilde key and type: /setblendbrush mybrush")]),e._v(" "),a("h3",{attrs:{id:"nextblendbrush"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nextblendbrush"}},[e._v("#")]),e._v(" nextblendbrush")]),e._v(" "),a("p",[a("code",[e._v("nextblendbrush N")])]),e._v(" "),a("p",[e._v("Selects the next brush after the current one if N is not specified, or is 1. Otherwise, it will advance the current brush selected by N over the list of brushes. N may be negative, in which case it will go backwards in the list of brushes. By default this is bound to the scroll wheel.")]),e._v(" "),a("h3",{attrs:{id:"rotateblendbrush"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rotateblendbrush"}},[e._v("#")]),e._v(" rotateblendbrush")]),e._v(" "),a("p",[a("code",[e._v("rotateblendbrush")])]),e._v(" "),a("p",[e._v("Rotates the current blend brush. By default this is bound to MOUSE2 (right mouse button).")]),e._v(" "),a("p",[e._v("First, texture the surfaces that you will want to paint with the textures that have had an extra texture layer defined for them in your map.cfg. You can only paint on textures that have had a second layer defined in the cfg. Now, you need to turn on a painting mode with the following command:")]),e._v(" "),a("h3",{attrs:{id:"blendpaintmode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blendpaintmode"}},[e._v("#")]),e._v(" blendpaintmode")]),e._v(" "),a("p",[a("code",[e._v("blendpaintmode N")])]),e._v(" "),a("p",[e._v("Where N is a number from 0 to 5, which defines how the painting will be done. Setting it to 0 turns paint mode off. Usually you should paint with mode 2. By default each of these modes are bound to their corresponding number on the numeric keypad.")]),e._v(" "),a("p",[e._v("Experiment with the numbers to understand what they do. Finally, in order to paint on to the surface, you would open the console and type")]),e._v(" "),a("h3",{attrs:{id:"paintblendmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#paintblendmap"}},[e._v("#")]),e._v(" paintblendmap")]),e._v(" "),a("p",[a("code",[e._v("paintblendmap")])]),e._v(" "),a("p",[e._v("If you've done everything right, you should see your first blended textures. By default this is bound to MOUSE1 (left mouse button).")]),e._v(" "),a("h3",{attrs:{id:"showblendmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#showblendmap"}},[e._v("#")]),e._v(" showblendmap")]),e._v(" "),a("p",[a("code",[e._v("showblendmap")])]),e._v(" "),a("p",[e._v("If for some reason the blendmap gets messed up while editing, you can use this command cause the blendmap to reshow without doing a full calclight.")]),e._v(" "),a("p",[e._v("There is NO UNDO for texture blending. If you've screwed something up, you can do one of two things. Open the console with the tilde key and type")]),e._v(" "),a("h3",{attrs:{id:"clearblendmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clearblendmap"}},[e._v("#")]),e._v(" clearblendmap")]),e._v(" "),a("p",[a("code",[e._v("clearblendmap")])]),e._v(" "),a("p",[e._v("This will delete ALL of the texture blending for the ENTIRE level.")]),e._v(" "),a("h3",{attrs:{id:"clearblendmapsel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clearblendmapsel"}},[e._v("#")]),e._v(" clearblendmapsel")]),e._v(" "),a("p",[a("code",[e._v("clearblendmapsel")])]),e._v(" "),a("p",[e._v("This will clear the texture blending on the selected geometry.")]),e._v(" "),a("p",[e._v("The amount of rendering passes the engine is required to make doubles on areas where the textures have been blended.")]),e._v(" "),a("h2",{attrs:{id:"entity-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entity-types"}},[e._v("#")]),e._v(" Entity Types")]),e._v(" "),a("p",[e._v("Entities are shown in editmode by blue sparklies.")]),e._v(" "),a("ul",[a("li",[e._v('"light" '),a("code",[e._v("radius r g b")])])]),e._v(" "),a("p",[e._v("If G and B are 0 the R value will be taken as brightness for a white light. A good radius for a small wall light is 64, for a middle sized room 128... for a sun probably more like 1000. Lights with a radius of 0 do not attenuate and may be more appropriate for simulating sunlight or ambient light; however, this comes at the cost of slightly greater map file sizes. See the lighting commands for an indepth list of all lighting related commands.")]),e._v(" "),a("ul",[a("li",[e._v('"spotlight" '),a("code",[e._v("radius")])])]),e._v(" "),a("p",[e._v('Creates a spotlight with the given "radius" (in degrees, 0 to 90). A 90 degree spotlight will be a full hemisphere, whereas 0 degrees is simply a line. These will attach to the nearest "light" entity within 100 units of the spotlight. The spotlight will shine in the direction of the spotlight, relative to the "light" entity it is attached to. It inherits the sphere of influence (length of the spotlight) and color values from the attached light as well. Do not move these very far from the light they\'re or attached to or you risk them detaching or attaching to the wrong lights on a map load!')]),e._v(" "),a("ul",[a("li",[e._v('"envmap" '),a("code",[e._v("[radius]")])])]),e._v(" "),a("p",[e._v('Creates an environment map reflecting the geometry around the entity. The optional radius overrides the maximum distance within which glass or geometry using the "bumpenv*" shaders will reflect from this environment map. If none is specified, the default is taken from the variable "envmapradius" (which defaults to 128 units), which may also be set in map cfgs. Environment maps are generated on a map load, or can be regenerated while editing using the "recalc" command. Please use the absolute minimum number of these possible. Each one uses up a decent amount of texture memory. For instance, rather than using two environment maps on each side of a window, use only one in the middle of the pane of glass. If you have a wall with many windows, place only one environment map in the middle of the wall geometry, and it should work just fine for all the windows.')]),e._v(" "),a("ul",[a("li",[e._v('"sound" '),a("code",[e._v("N radius [size]")])])]),e._v(" "),a("p",[e._v("Will play map-specific sound N so long as the player is within the radius. However, only up to the max uses allowed for N (specified in the mapsound command) will play, even if the player is within the radius of more N sounds than the max. By default (size 0), the sound is a point source. Its volume is maximal at the entity's location, and tapers off to 0 at the radius. If size is specified, the volume is maximal within the specified size, and only starts tapering once outside this distance. Radius is always defined as distance from the entity's location, so a size greater than or equal to the radius will just make a sound that is always max volume within the radius, and off outside.")]),e._v(" "),a("ul",[a("li",[e._v('"playerstart" '),a("code",[e._v("[Y] [T]")])])]),e._v(" "),a("p",[e._v('Spawn spot, yaw Y is taken from the current camera yaw (should not be explicitly specified to "newent"). If T is specified, then the playerstart is used as a team-spawn for CTF modes ONLY, where team T may be either 1 or 2, matching the parameter supplied to "flag" entities. For all other modes, team T should either be 0 or simply not specified at all! Note that normal playerstarts are never used for CTF, and CTF playerstarts are never used for spawns in other modes.')]),e._v(" "),a("ul",[a("li",[e._v('"flag" '),a("code",[e._v("[Y] T")])])]),e._v(" "),a("p",[e._v('A team flag for CTF maps ONLY. Yaw Y is taken from the current camera yaw (should not be explicitly specified to "newent"). Team T may be either 1 or 2. Playerstarts with a matching team will be chosen in CTF mode.')]),e._v(" "),a("ul",[a("li",[e._v('"base" '),a("code",[e._v("[ammo [N]]")])])]),e._v(" "),a("p",[e._v('A base for capture mode. If N is specified, the alias "base_N" will be looked up, and its value used for the name of the base, or otherwise a default name will be assigned. If ammo is specified, the base will always produce that type of ammo. If ammo is unspecified or 0, the server will randomly choose a type of ammo to produce at the start of the match. If ammo is negative, then it will pick a random type, but will match all other bases with the same negative ammo value. Ammo types are:')]),e._v(" "),a("ul",[a("li",[e._v('"shells"')]),e._v(" "),a("li",[e._v('"bullets"')]),e._v(" "),a("li",[e._v('"rockets"')]),e._v(" "),a("li",[e._v('"riflerounds"')]),e._v(" "),a("li",[e._v('"grenades"')]),e._v(" "),a("li",[e._v('"cartridges"')]),e._v(" "),a("li",[e._v('"health"')]),e._v(" "),a("li",[e._v('"healthboost"')]),e._v(" "),a("li",[e._v('"greenarmour"')]),e._v(" "),a("li",[e._v('"yellowarmour"')]),e._v(" "),a("li",[e._v('"quaddamage"')])]),e._v(" "),a("p",[e._v("A variety of pickup-able items, see "),a("a",{attrs:{href:"https://tomatenquark.org/#/game/GAMEPLAY",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("ul",[a("li",[e._v('"teleport" '),a("code",[e._v("N [M]")])]),e._v(" "),a("li",[e._v('"teledest" '),a("code",[e._v("[Y] N [P]")])])]),e._v(" "),a("p",[e._v("Creates a teleport connection, teleports are linked to a teledest with the same N (of which there should be exactly one). N can be 0..255. Y is the yaw of the destination and is initially taken from the current camera yaw, it cannot be specified when creating the entity. If M is 0 or not specified, the default teleporter model is used. If M is -1, no model is rendered for the teleporter. If M is a value 1 or greater, the corresponding mapmodel slot is used as the teleporter's model. If P is 1, the teledest preserves the velocity of the player, otherwise the player's velocity is reset upon teleporting.")]),e._v(" "),a("ul",[a("li",[e._v('"jumppad" Z '),a("code",[e._v("[Y] [X]")])])]),e._v(" "),a("p",[e._v('A jumppad entity which gives you a push in the direction specified. For example, "jumppad 30 5" makes you bounce up quite a bit and also pushes you forward a bit (so it is easier to land on a higher platform). This entity does not render anything, so you are responsible for creating something that looks logical below this entity.')]),e._v(" "),a("ul",[a("li",[e._v('"mapmodel" '),a("code",[e._v("[Y] N T R")])])]),e._v(" "),a("p",[e._v('A map model, i.e. an object rendered as obj/md2/md3/md5/iqm which you collide against, cast shadows etc. Y is the yaw of the model and is initially taken from the current camera yaw, it cannot be specified when creating the entity. N determines which mapmodel you want, this depends on "mapmodel" declarations in the maps cfg file. T specifies mapmodel behaviour such as triggers, see table below. R is the trigger number, 0 means no trigger. This number specifies what trigger to activate, and in addition, the alias "level_trigger_Trigger" will be executed, where Trigger is substituted accordingly (this allows you to script additional actions upon a trigger, i.e. put this into your map cfg file to print a message: alias level_trigger_1 "echo A door opened nearby"). The alias "triggerstate" will hold a value of -1, 0, or 1 indicating how the trigger was activated.')]),e._v(" "),a("p",[e._v('Be careful when using "switch many" for thing that affect gameplay, such as opening doors, as it can be confusing. Best is to reserve a particular model to mean "many" and others "once". All types >0 are snapped to 15 degree angles for orientation.')]),e._v(" "),a("ul",[a("li",[e._v('"box" '),a("code",[e._v("[Y] N W")])]),e._v(" "),a("li",[e._v('"barrel" '),a("code",[e._v("[Y] N W H")])])]),e._v(" "),a("p",[e._v('Like a mapmodel, except that damage done to it will push the entity around. Y is the yaw of the model and is initially taken from the current camera yaw, it cannot be specified when creating the entity. N determines which mapmodel you want, this depends on "mapmodel" declarations in the maps cfg file. W is the weight of the box or barrel where the heavier it is the less it moves; if W is not specified or 0, it defaults to 25. Barrels, unlike boxes, will explode if more than H damage is done to them; if H is not specified or 0, it defaults to 50.')]),e._v(" "),a("ul",[a("li",[e._v('"platform" '),a("code",[e._v("[Y] N T S")])]),e._v(" "),a("li",[e._v('"elevator" '),a("code",[e._v("[Y] N T S")])])]),e._v(" "),a("p",[e._v('Like a mapmodel, except it moves around and carries players, monsters, or other dynamic entities. Y is the yaw of the model and is initially taken from the current camera yaw, it cannot be specified when creating the entity. N determines which mapmodel you want, this depends on "mapmodel" declarations in the maps cfg file. A platform will travel horizontally back and forth along the direction of its yaw, while an elevator will travel only up and down. When they hit an obstacle such as geometry, they will reverse their direction. T is a tag that may be used to start or stop the elevator with the "platform" command; if a non-zero tag is specified, then the platform or elevator will stop upon hitting an obstacle, rather than reversing direction. S is the speed at which the entity moves, in units per second; if S is not specified or 0, it defaults to to 8.')]),e._v(" "),a("ul",[a("li",[e._v('"monster" '),a("code",[e._v("N [T]")])])]),e._v(" "),a("p",[e._v('A monster, currently N = 0..4 (see gameplay docs). Monster entities will be spawned when in classic single player mode, and will attack you when you come into view. yaw is taken from the current camera yaw. T is an optional tag number that is assigned to this monster. When the monster dies, the script alias "monster_dead_T" will be invoked.')]),e._v(" "),a("ul",[a("li",[e._v('"respawnpoint"')])]),e._v(" "),a("p",[e._v('A respawnpoint for classic SP mode (see "SP Respawning"), when the player dies, they will repsawn at the last one of these they touched, otherwise they start at the playerstart entity.')]),e._v(" "),a("ul",[a("li",[e._v('"particles" '),a("code",[e._v("type value1 value2 value3 value4")])])]),e._v(" "),a("p",[e._v("A particle emitter. Particles includes many of the effects as seen for weapons, explosions, and lens flares.")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[e._v("Type")]),e._v(" "),a("th",{staticStyle:{"text-align":"left"}},[e._v("Values")]),e._v(" "),a("th",{staticStyle:{"text-align":"left"}},[e._v("Description")])])]),e._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("0")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("radius, height, rgb (0x000..0xFFF) - 0 values are compat with older maps, otherwise radius&height=100 is a 'classic' size.")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("colored flames with smoke")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("1")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("direction (0..5)")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("steam vent")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("2")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("direction (0..5) - color comes from water color")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("water fountain")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("3")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("size (0..40), rgb (0x000..0xFFF)")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("explosion, i.e. fire ball [*expensive compared to other particles]")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("4")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("direction (0..5), length(0..100), rgb (0x000..0xFFF)")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("streak/flare")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("4")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("direction (256+effect), length(0..100), rgb (0x000..0xFFF)")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("multiple streak/flare effect"),a("br"),e._v("Effect - Description"),a("br"),e._v("0..2 - circular"),a("br"),e._v("3..5 - cylinderical shell"),a("br"),e._v("6..11 - conic shell"),a("br"),e._v("12..14 - cubic volume"),a("br"),e._v("15..20 - planar surface"),a("br"),e._v("21 - sphere"),a("br"),e._v("note: +32 to reverse direction of streaks")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("5")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("percentage (0..100), rgb (0x000..0xFFF)")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("capture meter, i.e. rgb vs black")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("6")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("percentage (0..100), rgb (0x000..0xFFF)")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("vs capture meter, i.e. rgb vs bgr")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("7")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("direction, length, rgb - see type 4")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("lightning")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("9")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("direction, length, rgb - see type 4")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("steam")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("10")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("direction, length, rgb - see type 4")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("water")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("11")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("radius, height, rgb - radius&height=100 is a 'classic' size")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("flames")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("12")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("radius, height, rgb - radius&height=100 is a 'classic' size")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("smoke plume")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("32")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("red (0..255), green (0..255), blue (0..255)")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("plain lens flare")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("33")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("red (0..255), green (0..255), blue (0..255)")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("lens flare with sparkle center")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("34")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("red (0..255), green (0..255), blue (0..255)")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("sun lens flare, i.e. fixed size regardless of distance")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("35")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("red (0..255), green (0..255), blue (0..255)")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("sun lens flare with sparkle center")])])])]),e._v(" "),a("h2",{attrs:{id:"pvs-culling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pvs-culling"}},[e._v("#")]),e._v(" PVS Culling")]),e._v(" "),a("p",[e._v('Cube 2 provides a precomputed visibility culling system as described in the technical paper "Conservative Volumetric Visibility with Occluder Fusion" by Schaufler et al (see paper for technical details). Basically, it divides the world into small cube-shaped "view cells" of empty space that the player might possibly occupy, and for each of these view cells calculates what other parts of the octree might be visible from it. Since this is calculated ahead of time, the engine can cheaply look up at runtime whether some part of the octree is possibly visible from the player\'s current view cell. Once pre-calculated, this PVS (potential visibility set) data is stored within your map and saved along with it, so that it may be reused during gameplay. This data is only valid for a particular map/octree, and if you change your map, you must recalculate it or otherwise expect culling errors. It is recommended you do this only after you are sure you are finished working on your map and ready to release it, as it can take a very long time to compute this data. If you have a multi-core processor or multi-processor system, it can use multiple threads to speed up the pre-calculation (essentially N processors/cores will calculate N times faster).')]),e._v(" "),a("p",[e._v('The number of pre-calculated view cells stored with your map will show up in the edit HUD stats under the "pvs:" stat. It is recommended you keep this number to less than 10,000, or otherwise the amount of storage used for the PVS data in your map can become excessive. For very large SP maps, up to 15,000 view cells is acceptable. The number of view cells is best controlled by use of the "clip" material, or by setting the view cell size (default is 32, equal to a gridpower 5 cube). View cell sizes of 64 or 128 are worth trying if your map still has an excessive number of view cells, but try to use the default view cell size of 32 if it stays reasonable. Note that if you have a map with a lot of open space, there will be a lot of view cells, and so the initial pre-calculation may take a long time. You can use the "clip" material, if necessary, to mark empty space the player can\'t go into, and the PVS calculation will skip computing view cells for these areas. Filling places the player can\'t go with solid cubes/sealing the map will similarly reduce the number of possible view cells.')]),e._v(" "),a("p",[e._v('Visibility from a view cell, to some other part of the octree, is determined by looking for large square or block-shaped surfaces and seeing if they block the view from the view cell to each part of the octree. So surfaces like large walls, ceilings, solid buildings, or even mountains and hills, that have large solid cross-sections to them will make the best occluders, and allow the PVS system to cull away large chunks of the octree that are behind them, with respect to the current view cell. Avoid putting holes running entirely through these structures, or this will prevent large cross-section of them from being used as an occluder (since the player could possibly see through them). You can use the "testpvs" command to check how well your occluders are working while building them. If your map is an open arena-style map, then using the PVS system will have little to no effect, since few things are blocking visibility, and it is not worth using the PVS system for such maps.')]),e._v(" "),a("p",[e._v("Note that there is already an occlusion culling system based on hardware occlusion queries, in addition to the PVS system, so the main function of the PVS system is to provide occlusion culling for older 3D hardware that does not support occlusion queries, and also to speed up occlusion queries by reducing the amount of such queries (which can be expensive themselves) even for 3D hardware that supports them. If PVS is used effectively (a map with lots of good occluders), it should always provide some speed-up regardless of whether or not the 3D hardware supports occlusion queries. However, if you are doing open arena-style maps for which there are few good occluders, then it is recommended you skip using the PVS system (as it will just take up memory without providing a speedup) and rely upon the hardware occlusion queries instead.")]),e._v(" "),a("h3",{attrs:{id:"pvs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pvs"}},[e._v("#")]),e._v(" pvs")]),e._v(" "),a("p",[a("code",[e._v("pvs N")])]),e._v(" "),a("p",[e._v("Toggles PVS culling, where N=1 enables it, and N=0 disables it. This is mostly useful for testing the performance effect of the PVS system and should usually be left on.")]),e._v(" "),a("h3",{attrs:{id:"pvsthreads"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pvsthreads"}},[e._v("#")]),e._v(" pvsthreads")]),e._v(" "),a("p",[a("code",[e._v("pvsthreads N")])]),e._v(" "),a("p",[e._v('Sets the number of threads (N) that will be used for calculating PVS info with the "genpvs" command. By default, only 1 thread (N=1) is used. If you have N processor or N processor cores, then set this variable to N to make the pre-calculation effectively N times faster. Setting this variable higher than the number of processors/cores will not make it any faster, but setting it lower will not utilize all of them, so try and set it to the exact number.')]),e._v(" "),a("h3",{attrs:{id:"genpvs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#genpvs"}},[e._v("#")]),e._v(" genpvs")]),e._v(" "),a("p",[a("code",[e._v("genpvs [N]")])]),e._v(" "),a("p",[e._v("Pre-calculates PVS data for the current version of the map. N is the size of the view cell used for calculation. If N is not specified or 0, then the default view cell size of 32 is used. Try to always use the default view cell size where reasonable.")]),e._v(" "),a("h3",{attrs:{id:"clearpvs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clearpvs"}},[e._v("#")]),e._v(" clearpvs")]),e._v(" "),a("p",[a("code",[e._v("clearpvs")])]),e._v(" "),a("p",[e._v("Clears the PVS data for the map. Use this to clear away stale PVS data if you are editing a map for which PVS data was already pre-calculated to avoid culling errors (i.e. stuff being invisible that should otherwise be visible).")]),e._v(" "),a("h3",{attrs:{id:"lockpvs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lockpvs"}},[e._v("#")]),e._v(" lockpvs")]),e._v(" "),a("p",[a("code",[e._v("lockpvs N")])]),e._v(" "),a("p",[e._v("If N=1, this locks the view cell used by the PVS culling to the current view cell, even if you happen to move outside of it. Everything that was occluded/invisible from that view cell will still be so, even if you move outside of it. This is useful for seeing all the things that are being culled from a current vantage point by the PVS system. If N=0, the view cell is unlocked and PVS will function as normal again.")]),e._v(" "),a("h3",{attrs:{id:"testpvs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#testpvs"}},[e._v("#")]),e._v(" testpvs")]),e._v(" "),a("p",[a("code",[e._v("testpvs [N]")])]),e._v(" "),a("p",[e._v('Generates PVS data for only the current view cell you are inside (of size N, or default 32 if not specified) and locks the view cell to it as if "lockpvs 1" were used. This allows you to quickly test the effectiveness of occlusion in your map without generating full PVS data, so that you can more easily optimize your map for PVS before the actual expensive pre-calculation is done. Use "lockpvs 0" to release the lock on the view cell when you are done testing. Note that this will not overwrite any existing PVS data already calculated for the map.')]),e._v(" "),a("h3",{attrs:{id:"pvsstats"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pvsstats"}},[e._v("#")]),e._v(" pvsstats")]),e._v(" "),a("p",[a("code",[e._v("pvsstats")])]),e._v(" "),a("p",[e._v("Prints out some useful info about the PVS data stored with the map, such as the number of view cells, the total amount of storage used for all the view cells, and the average amount of storage used for each individual view cell.")]),e._v(" "),a("h2",{attrs:{id:"waypoints"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#waypoints"}},[e._v("#")]),e._v(" Waypoints")]),e._v(" "),a("p",[e._v("Cube 2 provides waypoints to aid bot navigation, and without these bots are not able to calculate safe paths from place to place on the map.")]),e._v(" "),a("p",[e._v('Waypoints are entities in a map that tell where it is safe for bots to move to. Each waypoint can link to other waypoints, telling a bot how to get from one waypoint to another. To set up waypoints, first either add a bot (which causes you to drop waypoints as a side-effect) or set the "dropwaypoints" variable to 1. Run around the level through all valid paths, making sure to run through teleporters and touch all items and playerstarts. Waypoints should be dropped at ground level in an even grid across the map, i.e. only jump where it is necesssary to jump. Avoid any movement tricks like weapon jumping that might confuse the AI.')]),e._v(" "),a("p",[e._v('Set the "showwaypoints" variable to 1 so you can see the waypoints you are dropping, and you will see blue lines representing the links between these waypoints. When you are done, use the "savewaypoints" command to save the waypoints for your map; they will be saved to a file named "yourmap.wpt" for a map named "yourmap" in the same directory as your map. It also helps to add some bots before you save and make sure there are no bots stuck at playerstarts without waypoints to guide them.')]),e._v(" "),a("p",[e._v('Note waypoints are not loaded until required, i.e. until a "loadwaypoints" or "addbot" command is issued.')]),e._v(" "),a("h3",{attrs:{id:"showwaypoints"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#showwaypoints"}},[e._v("#")]),e._v(" showwaypoints")]),e._v(" "),a("p",[a("code",[e._v("showwaypoints 0/1")])]),e._v(" "),a("p",[e._v("Toggles showing of waypoints, where 1 enables it, and 0 disables it. This is mostly useful when laying waypoints so as to see the possible paths and ensure good coverage.")]),e._v(" "),a("h3",{attrs:{id:"dropwaypoints"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dropwaypoints"}},[e._v("#")]),e._v(" dropwaypoints")]),e._v(" "),a("p",[a("code",[e._v("dropwaypoints 0/1")])]),e._v(" "),a("p",[e._v('Toggles dropping of waypoints, where 1 enables it, and 0 disables it. By default the player is dropping waypoints whilst playing against bots, this enables bots to "learn" from the player. Note that if enabled, waypoints will be saved automatically once the map is changed, and the variable will then be reset back to 0.')]),e._v(" "),a("h3",{attrs:{id:"loadwaypoints"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loadwaypoints"}},[e._v("#")]),e._v(" loadwaypoints")]),e._v(" "),a("p",[a("code",[e._v("loadwaypoints [filename]")])]),e._v(" "),a("p",[e._v("Loads the waypoints for the current map (or specified file).")]),e._v(" "),a("h3",{attrs:{id:"savewaypoints"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#savewaypoints"}},[e._v("#")]),e._v(" savewaypoints")]),e._v(" "),a("p",[a("code",[e._v("savewaypoints [filename]")])]),e._v(" "),a("p",[e._v('Saves the waypoints for the current map (or specified file), e.g. as "'),a("mapname",[e._v('.wpt".')])],1),e._v(" "),a("h3",{attrs:{id:"clearwaypoints"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clearwaypoints"}},[e._v("#")]),e._v(" clearwaypoints")]),e._v(" "),a("p",[a("code",[e._v("clearwaypoints")])]),e._v(" "),a("p",[e._v("Removes all waypoints.")]),e._v(" "),a("h3",{attrs:{id:"delselwaypoints"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#delselwaypoints"}},[e._v("#")]),e._v(" delselwaypoints")]),e._v(" "),a("p",[a("code",[e._v("delselwaypoints")])]),e._v(" "),a("p",[e._v("In editing mode this will remove waypoints within the selection region.")]),e._v(" "),a("h2",{attrs:{id:"the-hud"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-hud"}},[e._v("#")]),e._v(" The HUD")]),e._v(" "),a("p",[e._v("On the bottom left of the screen are a bunch of stats. You'll find out what they mean below.")]),e._v(" "),a("ul",[a("li",[e._v("cube: the number of cubes in the current selection. Only the visible (leaf) cubes are counted.")]),e._v(" "),a("li",[e._v("fps: frames per second")]),e._v(" "),a("li",[e._v("ond: number of cubes in the system. This includes parent cubes, copied cubes, and undos.")]),e._v(" "),a("li",[e._v("va: number of vertex arrays used to store vertices in the map. You probably don't need to use this.")]),e._v(" "),a("li",[e._v("vtr: number of triangles currently being displayed. Will be a useful stat when culling is done.")]),e._v(" "),a("li",[e._v("vvt: number of vertices currently being displayed. Useful when culling is done.")]),e._v(" "),a("li",[e._v("tri: number of triangles in the entire map")]),e._v(" "),a("li",[e._v("wvt: number of vertices in the entire map")]),e._v(" "),a("li",[e._v("evt: misc rendering effects. Stuff like particles displayed, or text written on screen.")])]),e._v(" "),a("h3",{attrs:{id:"hidestats"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hidestats"}},[e._v("#")]),e._v(" hidestats")]),e._v(" "),a("p",[a("code",[e._v("hidestats 0/1")])]),e._v(" "),a("p",[e._v("Turn on to hide the above stats")]),e._v(" "),a("h3",{attrs:{id:"hidehud"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hidehud"}},[e._v("#")]),e._v(" hidehud")]),e._v(" "),a("p",[a("code",[e._v("hidehud 0/1")])]),e._v(" "),a("p",[e._v("Turn on to hide all HUD elements")]),e._v(" "),a("h3",{attrs:{id:"hudgun"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hudgun"}},[e._v("#")]),e._v(" hudgun")]),e._v(" "),a("p",[a("code",[e._v("hudgun 0/1")])]),e._v(" "),a("p",[e._v("Turn off to hide guns/hand")])])}),[],!1,null,null,null);t.default=r.exports}}]);